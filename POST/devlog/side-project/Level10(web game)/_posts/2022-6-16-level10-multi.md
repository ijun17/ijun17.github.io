---
layout: post
title: "WebRTC 멀티플레이 구현"
order: 5
---

멀티 플레이는 두 가지 방법으로 구현할 수 있다.

`client-server`
* 서버를 중간에 두고 두 클라이언트가 통신한다.
* 두 클라이언트의 동기화를 하는 것이 비교적 쉽다.
* 하지만 서버를 사용하므로 비용이 증가한다.

`p2p` 
* 두 클라이언트가 직접 통신한다.
* 두 클라이언트를 동기화하는 작업을 해야한다.
* 서버를 거의 사용하지 않는다.

# client-server로 멀티플레이 구현

처음에는 client-server로 구현을 하였다. 클라이언트는 서버에 자신의 입력 데이터(키보드)를 서버에 전송하고 게임의 연산은 서버에서 진행된다. 서버는 게임 내에 물체를 렌더링하는데 필요한 필수적인 데이터를 json형식으로 정리하여 클라이언트로 전송한다.

실행 결과는 느렸고 동시에 하나의 게임 밖에 할 수 없었다. 서버에서 게임에 관련된 연산을 하면서 1초에 30번씩 렌더링 데이터를 정리해서 클라이언트에 보내줘야했기 때문이다. 라즈베리 파이에 호스팅을 했기 때문에 느렸을 수도 있다.

이 방법은 핵으로부터 비교적 안전하기 때문에, 여러 플레이어의 트래픽을 감당할 수 있는 대형 게임에서 주로 사용하는 방법이다. 나 같은 경우는 이를 처리할만한 서버를 갖지 않았고, 핵 문제가 발생해도 나에게 발생하는 손해는 없다. 따라서 p2p방식으로 방향을 바꾸게 되었다. 


# p2p로 멀티플레이 구현

p2p 플레이 방식은 대표적으로 슈퍼 피어방식과 동등한 피어 방식이 있다. 슈퍼 피어는 한명의 피어가 서버와 같은 역할을 하는 것이고, 동등한 피어는 게임 연산을 각자의 컴퓨터에서 하는 것이다. 슈퍼 피어로 구현할려면 호스트와 게스트 구현을 따로해야하기 때문에 동등한 피어 방식으로 구현을 하였다.

## 일관성 유지

게임 연산을 각자가 하기 때문에 연산의 일관성을 유지시켜야 한다. 아래 조건이 만족하면 일관성이 유지될 것이라 생각된다.

1. **소수점 연산 결과가 모든 브라우저에서 같다.**: 이 게임은 브라우저 게임이다. 서로 다른 브라우저에서 연산결과가 같아야 한다.
2. **무작위 요소가 없다.**: Math.random() 뿐만 아니라 게임의 외부적인 요소(시간 등)가 게임에 영향을 끼쳐서는 안된다.
3. **사용자 입력의 처리가 동기적이다.**: 사용자 서로의 입력이 같은 틱에 처리되어야 한다.

1번과 다행히 같은듯하고, 2번은 그런 기능을 넣지 않으면 된다. 문제는 3번이다.

## 입력 동기화

1. 1~n틱 동안 각자의 입력 데이터를 수집한다.
2. n+1~2n틱 동안 상대에게 송신 요청 메시지를 보낸다
2. 상대에게 송신 요청 메시지를 받으면 입력 데이터를 송신한다.
3. 2n틱에 상대에게 입력데이터를 받지 않았으면 게임을 멈춘다.
4. 2n+1틱에 입력 데이터를 처리한다.

상대에게 보내는 메시지는 10자리의 문자열로 1~8자리는 입력, 9는 시간(틱), 10은 연산결과이다. 
재송신 메시지는 2자리로 

이 방식의 단점은 두 클라이언트 중 더 느린 클라이언트의 속도로 게임이 진행된다는 것이다.

## WebRTC

WebRTC를 사용해 두 클라이언트를 연결했다.
---
layout: post
title: "[3학년2학기]컴퓨팅문제와알고리즘"
order: 20
---

시험문제
* 시간복잡도 계산
* 병합 정렬

혹시? 
빌딩 블록, 지적 추상화
알고리즘 명확해야 하고 -, 효율적이어야함


# 알고리즘 복잡도

`점근적 분석`
* 입력의 크기가 큰 경우의 분석

`점근적 표기법`
* O(g(n)): 기껏해야 g(n)의 비율로 증가하는 함수
* Ω(g(n)): 적어도 g(n)의 비율로 증가하는 함수
* Θ(g(n)): g(n)의 비율로 증가하는 함수
* o(g(n)): g(n)보다 느린 비율로 증가
* ω(g(n)): g(n)보다 빠른 비율로 증가

시간복잡도 분석 종류
* Worst-case
* Average-case
* Best-case: 의미없음

# 재귀

`점화식`
* 현재 항을 한개 이상의 이전 항들로 표현한 식

점화식의 점근적 분석 방법
* 반복 대치
* 추정후 증명
* 마스터 정리


# 정렬

`선택정렬`
* 매 루프마다 최대 원소를 찾아 정렬되지 않은 맨 앞 원소와 교환
* O(n^2)

`버블정렬`
* 이웃한 쌍들을 비교해 교환. 루프의 결과로 맨 오른쪽에 가장 큰 값이 옴
* O(n^2)

`삽입정렬`
* 

`병합정렬`
* 배열을 반으로 나누어 정렬
* O(n log n) 

`퀵정렬`
* pivot을 기준으로 좌우로 수 이동. 분할 정복
* O(n log n) ~ O(n^2)

`힙정렬`
* 배열을 힙으로 만들고 하나씩 힙에서 제거해 정렬
* 힙 : 

`기수정렬`
* 원소들이 모두 k이하의 자릿수를 가졌을 때
* O(n)

`계수정렬`
* 원소들의 크기가 모두 범위 안에 있을 때 
* O(n)

||Worst case|Average case|
|:---:|:---:||
|정렬들|||




# 검색 트리

* 레코드 : 개체에 대한 저장 단위
* 필드 : 레코드에서 각각의 정보를 나타내는 부분
* 검색키 또는 키 : 각 레코드를 대표하는 고유한 필드
* 검색 트리 : 

## 이진검색트리

* 각 노드는 하나의 키 값
* 최대 두개 자식
* 왼쪽 자식 노드 < 노드 < 오른쪽 자식 노드
* 단점 : 균형이 깨지면 시간복잡도 증가

검색
* log n

삽입
* 

삭제
* 자식 0개 : 그냥 삭제
* 자식 1개 : 삭제하고 자식을 자신의 위치로
* 자식 2개 : 왼쪽 자식 노드를 오른쪽 자식 중에 가장 작은 값의 자식으로 바꿈


## 레드블랙트리

균형잡힌 이진검색트리

* 이진검색트리의 단점(unbalanced)을 보완하기 위해
* 각 노드에 색을 부여

## B-트리

균형잡힌 다진검색트리

* 루트를 제외한 모든 노드는 k/2~k개의 키를 갖는다
* 모든 리프노드는 같은 깊이를 가진다
* k: 
* 삽입이나 삭제를 통해 키 개수가 범위를 넘어설 경우(overflow, underflow) 재조합을 해야함

## 다차원 검색

검색키가 두개이상의 필드로 구성(예를들어 좌표)

* KD 트리
* KDB 트리
* R 트리
* 





# 상호 배타적 집합의 처리

연결리스트와 트리를 이용해 상호배타적 집합을 구현하고 연산 속도를 비교해 보자

`상호배타적 집합`: 중복이 없다

구현할 연산
* Make-Set(x): 원소 x로만 이루어진 집합을 만든다​
* Find-Set(x): 원소 x를 가지고 있는 집합을 알아낸다​
* Union(x,y): 원소 x를 가진 집합과 원소 y를 가진 ​집합의 합집합​

## 연결리스트로 구현

* 연결리스트의 맨 앞의 원소를 집합의 **대표 원소**로 한다.
* 모든 원소는 **대표 원소**를 포인터

`Union`
* 큰 집합 뒤에 작은 집합을 붙임(대표 원소 포인터 갱신 작업 최소화)
* m번의 Make-Set, Union, Find-Set 중 n번이 Make-Set이라면: O(m+ nlogn)

## 트리로 구현

* 트리의 루트를 대표원소로 삼는다
* 자식 노드가 부모 노드를 가리킨다​(루트는 루트를 가리킴)
* 부모도 자식 포인터(양방향임)

```cpp
Make-Set(x) // 노드 x를 유일한 원소로 하는 집합을 만든다. ​
{ ​
    p[x] ← x ; ​
} ​

Union(x, y) // 노드 x가 속한 집합과 노드 y가 속한 집합을 합친다 ​
{ ​
    p[Find-Set(y)] ← Find-Set(x) ; ​
} ​

Find-Set(x) //노드 x가 속한 트리의 루트 노드를 리턴한다. ​ ​
{​
    if (x  = p[x]) then ​return x ; ​
    else return Find-Set(p[x]) ; ​
} 
```

연산의 효율 높이기
* Rank(트리 높이)로 Union: 랭크가 높은 집합에 낮은 집합을 붙임
* 경로압축: Find-Set에서 만나는 모든 노드들이 부모 노드를 루트로

```cpp
Make-Set(x) // 노드 x를 유일한 원소로 하는 집합을 만든다. ​
{ ​
    p[x] ← x; ​
    rank[x] ← 0; ​
} ​

Union(x, y) // 노드 x가 속한 집합과 노드 y가 속한 집합을 합한다 ​
{ ​
    rx ← Find-Set(x); ​//x의 루트
    ry ← Find-Set(y); ​//y의 루트
    if (rank[rx] > rank[ry]) ​then p[ry] ← rx ; ​
    else { ​
        p[rx] ← ry ; ​
        if (rank[rx] = rank[ry]) then rank[ry] ← rank[ry] + 1; ​
    } ​
} 

Find-Set(x) //경로압축 - 부모를 루트로 하고 루트를 반환한다.
{ ​
    if (p[x] ≠ x) then p[x] ← Find-Set(p[x]); ​
    return p[x]; ​
} 
```






# 동적 프로그래밍

* 한번 수행한 연산을 기록함
* 재귀의 단점 : 같은 연산을 반복함(피보나치, 행렬곱셈 최적순서)
* 그러나 다음은 적당함 : 퀵정렬, 병합정렬, 팩토리얼, DFS...

적용 요건
* 최적 부분구조: 큰 문제의 최적 솔루션에 작은 문제의 최적 솔루션이 포함됨
* 재귀호출시 중복: 재귀 적용시 같은 연산이 심하게 중복됨

`행렬 경로 문제`
* n*n행렬에서 좌상단에서 우하단까지 방문한 칸에 합의 최소값
* 제약조건: 오른쪽이나 아래쪽으로만 이동할 수 있다.

`돌 놓기`
* 3*N 테이블 각 칸에 정수 기록
* 제약조건 : 가로, 세로 인접한 두 칸에 돌 못 놓음, 각 열에는 적어도 하나 이상 돌
* 목표 : 돌이 놓인 자리에 있는 수의 합의 최대값
* 해결 : 이전 상태(0,1,2,0과1)의 최대값을 저장

`행렬`
* 행렬곱 Ai…Aj를 구하는 최소 비용 구하기

`LSC`
* 


# 그래프 

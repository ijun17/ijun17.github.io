---
layout: post
title: "[3학년2학기]컴퓨팅문제와알고리즘"
order: 20
---

시험문제
* 슈도 코드(코드를 쓰는건 잘 안내고, 코드 주고 시간복잡도 얼마냐)
* 시간복잡도 무거운 순서
* 시간복잡도 계산
* 재귀 복잡도 분석
* 병합 정렬
* 각 정렬의 시간복잡도(증명은 안내고 시간복잡도만 단답형으로)
* 코드 보고 무슨 정렬인지
* 무슨 정렬이 안정성 정렬
* 힙 만드는 과정
* 트리 삽입 삭제 순서
* 레드블랙 트리 균형 맞추는 거
* B-트리 오버플로우, 언더플로우
* KDB 트리 삽입 삭제
* R 트리
* 해시 테이블 충돌 해결 방식 - 체이닝, 개방 주소 방식(1차원, 2차원, 더블 해싱)
* 집합(상호배타적) - tail에 뭐들어가는지
* 집합 트리로 구현(트리의 높이가 낮은게 높은것의 서버트리로 들어감, 랭크가 같은 경우)
* 트리 경로 압축 



# 알고리즘 복잡도

`점근적 분석`
* 입력의 크기가 큰 경우의 분석

`점근적 표기법(임의의 표기법 X에 대해 f(n) = X(g(n))일 때)`
* 빅오 O(g(n)): f <= c\*g (점근적 상한)   *ex) n^(2이하인 수) = O(n^2)*
* 빅오메가 Ω(g(n)): f >= c\*g (점근적 하한)   *ex) n^(2이상인 수) = Ω(n^2)*
* 빅세타 Θ(g(n)): c1\*g <= f <= c2\*g (상하한)   *ex) n^2 = Ω(n^2)*
* 스몰오 o(g(n)): f < c\*g (점근적 상한)   *ex) n^(2미만인 수) = O(n^2)*
* 스몰오메가 ω(g(n)): f > c\*g (점근적 하한)   *ex) n^(2초과인 수) = Ω(n^2)*

시간복잡도 분석 종류
* Worst-case
* Average-case
* Best-case: 의미없음




# 재귀

`점화식`
* 현재 항을 한개 이상의 이전 항들로 표현한 식

## 점화식의 점근적 분석 방법

`반복 대치` 
* 이전 항으로 반복해서 대치해가며 n에 대한 식으로 정리하는 방법

`추정후 증명`
* 점근적 복잡도를 미리 추정한다음 귀납적으로 증명

`마스터 정리` 
* 특정한 형태의 재귀식에 대한 복잡도 공식
* T(n) = a\*T(n/b) + f(n)이고 h(n) = n^(log b a)에서 <br>
  f(n) / h(n) = F라 하고 양의 상수 k에 대해
    1. F = O(n^(-k))이면 T(n) = Θ(h(n))
    2. F = Ω(n^k)이고, a\*f(n/b) <= c\*f(n)이면 T(n) = Θ(f(n))
    3. F = Θ(1)이면 T(n) = Θ(h(n) \* log n)

`마스터 정리 근사 버전`
* 마스터 정리와 같은 의미는 아니지만 거의 일치, 반례를 찾기 어려움
* T(n) = a\*T(n/b) + f(n)에서 h(n) = n^(log b a)라고 할 때 
    1. h(n)이 더 무거우면 Θ(h(n))
    2. f(n)이 더 무거우면 Θ(f(n))
    3. h와 f가 같은 무게면 Θ(h(n)\*log n)





# 정렬

`선택정렬`
* 각 루프마다 최대 원소를 찾아 정렬되지 않은 맨 오른쪽 원소와 교환
* O(n^2)

`버블정렬`
* 이웃한 쌍들을 비교해 교환. 루프의 결과로 맨 오른쪽에 가장 큰 값이 옴
* O(n^2)

`삽입정렬`
* 배열의 정렬된 구간을 1씩 증가
* O(n^2)

`병합정렬`
* 배열을 반으로 나누어 정렬
* O(n log n) 

`퀵정렬`
* pivot(첫번째 원소)을 기준으로 좌우로 수 이동. 분할 정복
* O(n log n) ~ O(n^2)

`힙정렬`
* 배열을 힙으로 만들고 하나씩 힙에서 제거해 정렬
* 힙 : 균형잡힌 이진 트리, 부모는 자식보다 작다(최소힙)
    * 삽입: 마지막 리프에 삽입하고 부모와 대소 비교하여 교환
    * 삭제: 루트 삭제 후 마지막 리프를 루트로 놓고 자식과 대소 비교하여 교환
* O(n log n) 

`기수정렬`
* 원소들이 모두 k이하의 자릿수일 때 1번째 자릿수부터 비교하며 정렬
* O(n)

`계수정렬`
* 원소들의 크기가 모두 범위 안에 있을 때 
* O(n)

**안정성 정렬** : 정렬 후에도 같은 값의 원소들의 기존 순서를 유지



# 검색 트리

* 레코드 : 개체에 대한 저장 단위
* 필드 : 레코드에서 각각의 정보를 나타내는 부분
* 검색키 또는 키 : 각 레코드를 대표하는 고유한 필드
* 검색 트리 : 

## 이진검색트리

* 각 노드는 하나의 키 값
* 최대 두개 자식
* 왼쪽 자식 노드 < 노드 < 오른쪽 자식 노드
* 단점 : 균형이 깨지면 시간복잡도 증가

검색
* log n

삽입
* 

삭제
* 자식 0개 : 그냥 삭제
* 자식 1개 : 삭제하고 자식을 자신의 위치로
* 자식 2개 : 왼쪽 자식 노드를 오른쪽 자식 중에 가장 작은 값의 자식으로 바꿈


## 레드블랙트리

균형잡힌 이진검색트리

여기서의 리프 노드는 자식 중에 NIL을 하나로 연결한 노드를 뜻함

**레드블랙특성**
1. 루트는 블랙
1. 모든 리프(NIL)은 블랙(무시해도 됨)
1. 노드가 레드이면 그 노드의 자식은 반드시 블랙
1. 루트 노드에서 임의의 리프 노드까지 만나는 블랙의 수는 모두 같다

부모를 p, 부모의 부모를 p2, 부모의 형제를 s라 함

**삽입**
* 이진검색트리처럼 리프에 삽입 후(레드로), 레드블랙특성을 위반하는지 확인
* case1 p,s가 레드라면: p2를 레드로 p와 s를 블랙으로
* case2 p가 레드, s가 블랙: p를 중심으로 왼쪽으로 회전
* case3 

## B-트리

균형잡힌 다진검색트리

* 루트를 제외한 모든 노드는 k/2~k개의 키를 갖는다
* 모든 리프노드는 같은 깊이를 가진다
* k: 
* 삽입이나 삭제를 통해 키 개수가 범위를 넘어설 경우(overflow, underflow) 재조합을 해야함

## 다차원 검색

검색키가 두개이상의 필드로 구성(예를들어 좌표)

* KD 트리
* KDB 트리
* R 트리
* 





# 상호 배타적 집합의 처리

연결리스트와 트리를 이용해 상호배타적 집합을 구현하고 연산 속도를 비교해 보자

`상호배타적 집합`: 중복이 없다

구현할 연산
* Make-Set(x): 원소 x로만 이루어진 집합을 만든다​
* Find-Set(x): 원소 x를 가지고 있는 집합을 알아낸다​
* Union(x,y): 원소 x를 가진 집합과 원소 y를 가진 ​집합의 합집합​

## 연결리스트로 구현

* 연결리스트의 맨 앞의 원소를 집합의 **대표 원소**로 한다.
* 모든 원소는 **대표 원소**를 포인터

`Union`
* 큰 집합 뒤에 작은 집합을 붙임(대표 원소 포인터 갱신 작업 최소화)
* m번의 Make-Set, Union, Find-Set 중 n번이 Make-Set이라면: O(m+ nlogn)

## 트리로 구현

* 트리의 루트를 대표원소로 삼는다
* 자식 노드가 부모 노드를 가리킨다​(루트는 루트를 가리킴)
* 부모도 자식 포인터(양방향임)

```cpp
Make-Set(x) // 노드 x를 유일한 원소로 하는 집합을 만든다. ​
{ ​
    p[x] ← x ; ​
} ​

Union(x, y) // 노드 x가 속한 집합과 노드 y가 속한 집합을 합친다 ​
{ ​
    p[Find-Set(y)] ← Find-Set(x) ; ​
} ​

Find-Set(x) //노드 x가 속한 트리의 루트 노드를 리턴한다. ​ ​
{​
    if (x  = p[x]) then ​return x ; ​
    else return Find-Set(p[x]) ; ​
} 
```

연산의 효율 높이기
* Rank(트리 높이)로 Union: 랭크가 높은 집합에 낮은 집합을 붙임
* 경로압축: Find-Set에서 만나는 모든 노드들이 부모 노드를 루트로

```cpp
Make-Set(x) // 노드 x를 유일한 원소로 하는 집합을 만든다. ​
{ ​
    p[x] ← x; ​
    rank[x] ← 0; ​
} ​

Union(x, y) // 노드 x가 속한 집합과 노드 y가 속한 집합을 합한다 ​
{ ​
    rx ← Find-Set(x); ​//x의 루트
    ry ← Find-Set(y); ​//y의 루트
    if (rank[rx] > rank[ry]) ​then p[ry] ← rx ; ​
    else { ​
        p[rx] ← ry ; ​
        if (rank[rx] = rank[ry]) then rank[ry] ← rank[ry] + 1; ​
    } ​
} 

Find-Set(x) //경로압축 - 부모를 루트로 하고 루트를 반환한다.
{ ​
    if (p[x] ≠ x) then p[x] ← Find-Set(p[x]); ​
    return p[x]; ​
} 
```






# 동적 프로그래밍

* 한번 수행한 연산을 기록함
* 재귀의 단점 : 같은 연산을 반복함(피보나치, 행렬곱셈 최적순서)
* 그러나 다음은 적당함 : 퀵정렬, 병합정렬, 팩토리얼, DFS...

적용 요건
* 최적 부분구조: 큰 문제의 최적 솔루션에 작은 문제의 최적 솔루션이 포함됨
* 재귀호출시 중복: 재귀 적용시 같은 연산이 심하게 중복됨

`행렬 경로 문제`
* n*n행렬에서 좌상단에서 우하단까지 방문한 칸에 합의 최소값
* 제약조건: 오른쪽이나 아래쪽으로만 이동할 수 있다.

`돌 놓기`
* 3*N 테이블 각 칸에 정수 기록
* 제약조건 : 가로, 세로 인접한 두 칸에 돌 못 놓음, 각 열에는 적어도 하나 이상 돌
* 목표 : 돌이 놓인 자리에 있는 수의 합의 최대값
* 해결 : 이전 상태(0,1,2,0과1)의 최대값을 저장

`행렬`
* 행렬곱 Ai…Aj를 구하는 최소 비용 구하기

`LSC`
* 


# 그래프 

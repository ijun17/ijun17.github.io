---
layout: post
title: "[3학년1학기]소프트웨어개발프로세스"
order: 30
---

테스트 용어 - sten에서 확인
테스트 케이스
사용자 스토리(참고 자료)
소프트웨어 케이스 툴 정리

# 폭포수 모델

`폭포수 모델(waterfall model)` : 소프트웨어 개발 프로세스의 하나로, 시스템 개발을 **단계적으로** 진행하는 방법론

### 폭포수 모델 단계

1. 요구사항 분석
2. 설계
3. 코딩과 단위 테스트
4. 시스템 통합
5. 관리와 유지보수

### 폭포수 모델 단점

* 제대로 시간 투자를 해야만 요구사항을 이해할 수 있다 > 시간이 오래걸릴 수록 새로운 요구사항을 구현하는데 오래걸림
* 요구사항의 변경은 많지 않으며 수용가능할 것이다 > 개발 기간은 요구사항 변경과 비례
* 독립적인 팀으로부터 나온 대규모 코드로 시스템 통합하는 것은 어려움
* 예정대로 일정이 수립되기 어렵다







# 애자일 방법론

`애자일 방법론(Agile Process)` : 소프트웨어 개발 프로세스의 하나로, 빠르고 유연하게 진행하면서 **변경에 빠르게** 대응하는 방법론

`애자일 선언문` : "상호작용하는 개인", "동작하는 SW", "고객과의 협력", "변화에 대한 수용"

### 애자일의 목표

가치 있는 소프트웨어를 조속하게 릴리즈

### 애자일 등장배경

기존의 무거운 폭포수 방법론을 타파하기 위해 경량방법론이 나왔고, 애자일 선언문 이후에 애자일로 불림

### 애자일의 장점

1. 요구사항 변화에 빠르게 대응
1. 비용이 적다
1. 반복적인 릴리즈로 고객 만족도가 높음

### 애자일 폭포수 차이

|**애자일 방법론**|**폭포수 방법론**|
|:--:|:--:|
|반복 점진적|단계별로 진행|
|고객 중심|계획 중심|
|짧은 주기로 작은 릴리즈|한꺼번에 빅뱅 릴리즈|
|동작하는 SW중심|단계별 산출물 중심|
|가벼운 방법론|무거운 방법론|

### 애자일 방법론 종류

* `eXtreme Programming` : 고객 팀과 함께 개발, 요구사항은 **사용자 스토리**로. 페어 프로그래밍, 엄격한 코딩 표준, 단위테스트
* `Scrum` : **스프린트**라는 개발주기(30일 권장)로 진행. 모든 작업은 **백로그**에 기록. 팀을 관리하는 스크럼 마스터. 매일 **스탠드업 미팅**에서 정보교환. 정해진 시간은 철저히.
* `RUP(Rational Unified Process)` : 소프트웨어 개방 방법론이자 **프로세스 프레임워크**. UML 기반의 프로세스(RUP가 애자일인지에 대한 논쟁이 있음). RUP의 애자일 버전이 존재(Agile UP, OpenUp 등)





# XP

`xp(eXtreme Programming)` : 빠르게 변하는 요구사항에 대응하는 중소규모 팀을 위한 애자일 방법론이다.

### XP 특징
* 5~10명의 프로그래머와 **고객이 한 장소에서** 작업
* 개발은 **점진적으로**, 각 단계마다 산출물들의 기능을 덧붙임
* `사용자 스토리`로 요구사항을 **간략하고 명확한 문장**으로 정의
* **엄격한 코딩 규칙**, **pair programing**, **단위테스트**
* 요구사항, 아키텍처, 디자인은 **언제든지 발생**

### XP 논쟁
* 기존의 방법론과 판이하게 다름
* 초기에 설계를 끝내고 진행하는 것을 지양
* 문서화 작업을 최소화(대신 코드에 주석을 달고, 테스트 케이스를 개발)
* pair programing, TDD
* XP의 극단성(어떤것이 좋다면 항상, 모든 사람이 같이 수행)

### (시험✔)XP 핵심가치

1. `의사사통` : 프로그래머들 간 대화방법과 팀과 고객들 간의 대화 방법을 강조
2. `단순성` : '꼭 필요한 것만 한다.' 가장 간단한 설계는 코드를 작성하는 것, 복잡한 설계는 잘못된 부분을 지속적으로 리팩토링 
3. `피드백` : 개발을 하면서 고객으로부터 자주 피드백아야함.
4. `용기` : TDD, 가장 간단한 솔루션, 피드백, 리팩토링 할 수 있는 용기 
5. `존중` : 팀원 간의 상호 존중을 강조. 존중이 되어야 위에 가치들이 가능.

### XP 13가지 주요 활동

함께 앉기, 하나의 팀, 정보를 제공하는 작업 공간, 열정적인 작업, 페어 프로그래밍, 스토리, 주 단위의 주기, 사분기 주기, 느슨함, 10분 빌드, 지속적인 통합, 테스트 우선 프로그래밍, 점진적 설계.

### XP의 프로세스 모델

1. 아키텍처 스파이크 : 팀이 설계 또는 리팩토링을 하거나 새로운 기술을 적용할 때 프로토타입
2. 릴리스 계획 : 릴리스를 성공하는데 필요한 각 주기 정의
3. 반복 : 새로운 사용자 스토리가 발생하면 릴리스 계획으로 돌아감
4. 인수 테스트 : 고객이 작성하여 기능을 검사하여 승인되면 작은 릴리스를 진행
5. 작은 릴리스 : 짧은 주기로 업데이트된 모듈을 릴리스 하는것

* 사용자 스토리 : 간단 명료하게 구현한 요구사항
* 아키텍처 스파이크 : 초반에 구현을 위한 실험들. 팀이 설계를 하거나 리팩토링을 하거나 새로운 기술을 적용시킬 때 그 바탕이 되는 것
* 스파이크(spike) : 실험을 위한 프로토타입. 기술적 문제, 설계 문제의 해결책을 찾는것
* 속도(velocity) : 주어진 기간동안 완료할 수 있는 업무의 양. 단위는 스토리 포인트
* 스토리 포인트 : 사용자 스토리의 크기를 나타내는 인수 단위로 사용자 스토리를 구현하는데 소요되는 비용 / 릴리스 계획 및 인수테스트의 토대 / 플래닝 포커 참조

### XP 제한성

* 시간이 지날수록 변경의 비용이 급격하게 증가하는 프로젝트
* 안정성이 중요한 시스템(인간의 생명이 달린)
* 정형화, 문서화를 중시하는 팀
* 주당 40시간 근무가 어려운 팀
* 지속적인 통합과 테스트가 불가능한 프로젝트
* 직접 만나지 못하는 팀 






# 스크럼

`스크럼(Scrum)`은 애자일 방법론 중 하나로, 추정 및 조정 기반의 경험적 관리기법을 적용한 방법론

스크럼의 용어는 럭비에서 유래. 
**동시공학(Concurrent Engineering)**을 적용해 설계,빌드,테스팅을 협업하여 동시에 수행.
경험적 프로세스 제어 : 소프트웨어개발은 본래 복잡하고 예측이 불가능한 프로세스이므로 '정의'보다는 '경험'에 의한 접근법으로 진행

### 스크럼 역할

* `Scrum Master` : 팀이 스크럼을 잘 수행할 수 있도록 돕는 역할
* `Product Owner` : 고객의 대표로 제품 백로그를 관리. 스프린트에는 관여하지 않음
* `Scrum Team` : 하나의 스프린트를 진행하는 권한을 가진 팀

### 스크럼 용어

* `Sprint` : 제품 릴리스를 위한 약 30일 동안 작업
* `Story Point` : 개발할 사용자스토리의 크기를 나타내는 단위
* `Task` : 사용자스토리를 구현하기 위한 작업
* 산출물 `Product Backlog` : 제품 기능들의 우선순위를 정리한 목록
* 산출물 `Sprint Backlog` : 하나의 스프린트 동안 개발할 task의 목록
* 산출물 `Burndown Chart(소멸차트)` : Y-Story Point, X-Date
* `Sprint Planning` : 제품 백로그로 스프린트 백로그를 만들고 팀을 구성하는 회의.
* `Daily Scrum` : 매일 15분 동안 프로젝트 진행상황(한일, 할일, 방해요소)을 공유하는 회의
* `Sprint Review` : 스프린트 목표를 달성했는지 작업 진행과 결과물을 확인하는 회의. 회고를 진행할 수 있음
* `Retrospective(회고)`: 프로젝트 끝에 그 간의 일들을 돌아보고 경험했던 것을 통해 학습하고 더 나아지기 위한 변화를 계획하는 일련의 활동


### 스크럼의 핵심 활동

* 스프린트를 진행하는 팀은 기능협업(cross-functional) 기준으로 배치
* 스프린트는 30일의 사이클로 테스트가 완료되면 점진적으로 릴리스
* 한 스프린트에서 수행하는 작업은 고정적이며, 개발팀만 바꿀 수 있음
* 모든 작업은 백로그에 기록(요구사항, 내부 구조 및 설계)
* 제품 책임자는 외부 고객과 교류하는 역할을 하는 팀의 일원
* 일일 스탠드업 또는 일일 스크럼에서 정보교환
* 스프린트, 스탠드업 미팅, 릴리스 리뷰 미팅 등은 정해진 시간을 철저히
* 스크럼에서는 요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 드러나야 한다.

스프린트 종료 시 나오는 모든 산출물은 잠재적으로 릴리스 가능하도록 해야한다. 세번의 스프린트마다 릴리스를 하도록 권고하고 있다.

### 스크럼 특징

* **투명성** : 스크럼 회의, 소멸차트, 스크린트 리뷰를 통해 프로젝트의 상태나 문제점을 잘 드러냄
* **타임 박싱** : 여러 미팅들을 주기적으로 하고 있지만, 시간을 엄격하게 제한함으로써 개발에 집중
* **커뮤니케이션** : 일일 스크럼과 플래닝 포커라는 방식으로 커뮤니케이션을 원할하게 할 수 있게함
* **경험주의 모델(inspect & adapt model)** : 개개인의 경험을 기반으로 함
    * 경험적 프로세스 제어 : 조사해서 잘못된 점을 변경해 나간다.


### 스크럼 부적절한 경우

* 곳곳에 흩어져있는 대규모 팀
* 팀원에게 권한을 주지 않는 팀 문화
* 지속적인 통합과 테스트가 불가능한 프로젝트
* 변화를 수용하지 못하는 조직 문화




# RUP(Rational Unified Process)

### RUP란

`RUP(Rational Unified Process)` : **UML**을 사용하는 소프트웨어 개발 프로세스이며, **프로세스 프레임워크**

`UML(Unified Modeling Languge)` : 소프트웨어 개발에서 결과물을 명세화,시각화,문서화하는 통합 모델링 언어

RUP와 UML 모두 Rational Software(현 IBM)에서 개발된 것이다. 
`프로세스 프레임워크` : 소프트웨어 개발이나 프로젝트 관리와 같은 작업을 수행하는 데 사용하는 일련의 프로세스와 관련된 가이드, 원칙, 도구, 템플릿 등의 모음. RUP는 프로세스 프레임워크로서 사용자의 요구에 따라 작업을 빼거나 추가할 수 있다.

RUP에는 여러 종류가 있으며, 애자일처럼 반복 점진적인 특성을 같지만 모든 RUP가 애자일이라고 하기는 어렵다. 왜냐하면 애자일 선언문에 참석하지 않고 UML을 통해 여러 산출물을 내기 때문
애자일이라 할 수 있는 RUP는 

### RUP 특징
* 4가지 생산단계
* 개발에 필요한 많은 방법론과 SW공학활동을 제공
* 반복적인 프로세스
* 점진적인 프로세스

### RUP 8가지 핵심이론

* 주요 위험 요소들을 조기에 해결
* 고객에게 가치를 전달
* 실행 가능한 소프트웨어에
* 변경사항에 대한 신속한 수용
* 초기 실행 가능한 아키텍처의 기초작업
* 시스템은 컴포넌트로
* 하나의 팀
* 품질 개선을 위해 상시 노력

### RUP 4가지 단계
X-축
* 개념화(Conseption) : 비즈니스 케이스를 구축하고 시스템이 어떤 문제에 직면할지 알아내는 것. 산출물로 비즈니스 모델, 비전 문서, 프로토타입을 만든다.
* 정교화(Eleboration) : 시스템의 정의와 아티텍처를 구현. 산출물로 유스케이스 모델과 실행가능한 기본 아키텍처가 있다.
* 구축(Construction) : 
* 전이(Tansition) :

Y-축
* 




# 프로세스 비교

## SEI CMM

**SEI CMM**은 프로세스 평가 프레임워크이다.

높은 ceremony

## SEI CMMI

**SEI CMMI** 또한 프로세스 평가 프레임워크이다.



# 코드 리팩토링 실습

## java 문법

```java
public enum E{
    A,B,C,D;
    public String toString(){
        switch(this){
            case A: return "A";
            ...
            default: return "X"; 
        }
    }
}

//연결리스트 순회
List list = new LinkedList();
for(Iterator i=list.iterator(); i.hasNext(); ){
    A a=(A)i.next();
}

//연결리스트 추가
list.add(3);

//소문자로
(String).toLowerCase();

//문자열 비교
String.equals(String);


```

## 용어

`결합도(Coupling)` : 객체가 얼마나 연결되었는지
`응집도(Cohension)` : 
`OCP(Open Close Principle)` : 개방폐쇄원칙
`디자인 패턴` : *헤드퍼스트 디자인 패턴 책 참고

``

## 코드 기능

기타, 인벤토리 객체가 있음 인벤토리는 기타들을 저장하고 인벤토리 안에서 기타를 탐색하는 기능을 한다. 
테스트 클래스는 인벤토리에 기타 들을 저장하고, 기타를 탐색하는 기능을 한다.

## 1. start

문제점
1. 기타 탐색에서 문자를 정확히 입력해야함(테스트 코드는 대소문자 차이로 탐색 안됨) -> 소문자로만 가능하게 하던가 enum으로
2. 인벤토리에 조건에 맞는 기타가 여러개 있을 수 있지만 처음 발견한 기타 한개만 반환 -> 링크드리스트 또는 인벤토리로 반환
3. 인벤토리 기타 탐색 기능에 기타 객체와 강하게 결합됨 -> 순차적으로 기타를 비교하는 것은 인벤토리에 직접 속성을 비교하는 것은 기타에 할당

## 2. coice

변경사항
1. 기타 속성들의 종류를 enum으로 정의해놓음
2. 기타 탐색 후 리스트 반환

문제점
1. 인벤토리에 기타를 넣는 메소드에 매개변수로 기타의 모든 속성을 받아 결합큼 -> 기타 객체를 매개변수로
2. 여전히 탐색 메소드의 기타 비교 로직을 인벤토리가 담당


*자바 다중상속 불가(인터페이스는 가능)
*인터페이스에 의존하라 자식보단 부모에게 의존
*





# 
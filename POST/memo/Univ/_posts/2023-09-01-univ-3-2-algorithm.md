---
layout: post
title: "[3학년2학기]컴퓨팅문제와알고리즘"
order: 20
---

시험문제
* 시간복잡도 계산
* 병합 정렬

# 과제

## HW1 

* 마지소트, 퀵소트, 힙소트 성능 비교
* 알고리즘_HW1_이름.hwp
* 9월 29일 금요일까지


# 알고리즘 복잡도

`점근적 분석`
* 입력의 크기가 큰 경우의 분석

`점근적 표기법`
* O(g(n)): 기껏해야 g(n)의 비율로 증가하는 함수
* Ω(g(n)): 적어도 g(n)의 비율로 증가하는 함수
* Θ(g(n)): g(n)의 비율로 증가하는 함수
* o(g(n)): g(n)보다 느린 비율로 증가
* ω(g(n)): g(n)보다 빠른 비율로 증가

시간복잡도 분석 종류
* Worst-case
* Average-case
* Best-case: 의미없음

# 재귀

`점화식`
* 현재 항을 한개 이상의 이전 항들로 표현한 식

점화식의 점근적 분석 방법
* 반복 대치
* 추정후 증명
* 마스터 정리


# 정렬

`선택정렬`
* 매 루프마다 최대 원소를 찾아 정렬되지 않은 맨 앞 원소와 교환
* O(n^2)

`버블정렬`
* 이웃한 쌍들을 비교해 교환. 루프의 결과로 맨 오른쪽에 가장 큰 값이 옴
* O(n^2)

`삽입정렬`
* 

`병합정렬`
* 배열을 반으로 나누어 정렬
* O(n log n) 

`퀵정렬`
* pivot을 기준으로 좌우로 수 이동. 분할 정복
* O(n log n) ~ O(n^2)

`힙정렬`
* 배열을 힙으로 만들고 하나씩 힙에서 제거해 정렬
* 힙 : 

`기수정렬`
* 원소들이 모두 k이하의 자릿수를 가졌을 때
* O(n)

`계수정렬`
* 원소들의 크기가 모두 범위 안에 있을 때 
* O(n)

||Worst case|Average case|
|:---:|:---:||
|정렬들|||




# 검색 트리

* 레코드 : 개체에 대한 저장 단위
* 필드 : 레코드에서 각각의 정보를 나타내는 부분
* 검색키 또는 키 : 각 레코드를 대표하는 고유한 필드
* 검색 트리 : 

## 이진검색트리

* 각 노드는 하나의 키 값
* 최대 두개 자식
* 왼쪽 자식 노드 < 노드 < 오른쪽 자식 노드
* 단점 : 균형이 깨지면 시간복잡도 증가

검색
* log n

삽입
* 

삭제
* 자식 0개 : 그냥 삭제
* 자식 1개 : 삭제하고 자식을 자신의 위치로
* 자식 2개 : 왼쪽 자식 노드를 오른쪽 자식 중에 가장 작은 값의 자식으로 바꿈


## 레드블랙트리

균형잡힌 이진검색트리

* 이진검색트리의 단점(unbalanced)을 보완하기 위해
* 각 노드에 색을 부여

## B-트리

균형잡힌 다진검색트리

* 루트를 제외한 모든 노드는 k/2~k개의 키를 갖는다
* 모든 리프노드는 같은 깊이를 가진다
* k: 
* 삽입이나 삭제를 통해 키 개수가 범위를 넘어설 경우(overflow, underflow) 재조합을 해야함

## 다차원 검색

검색키가 두개이상의 필드로 구성(예를들어 좌표)

* KD 트리
* KDB 트리
* R 트리
* 

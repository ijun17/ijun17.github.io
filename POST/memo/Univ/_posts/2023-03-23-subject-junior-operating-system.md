---
layout: post
title: "[3학년1학기]운영체제(작성중)"
order: 30
---

# 운영체제의 개요

컴퓨터는 크게 하드웨어와 소프트웨어로 나뉜다. 소프트웨어는 또 **응용 프로그램**과 **시스템 소프트웨어**로 나뉜다. 시스템 소프트웨어은 또 `운영체제`와 `유틸리티`가 있다. 운영체제(OS)란 응용 프로그램의 잘못된 동작으로 컴퓨터가 망가지는 것을 막기 위해 컴퓨터 전체를 관리하고 운영하는 소프트웨어이다. 유틸리티란 운영체제의 기능이 많아지자 운영체제의 작업을 보조하기 위해 바이러스 검사, 디스크 조각 모음, 압축 


임베디드 운영체제는 CPU 성능이 낮고 메모리와 디스플레이 크기가 작은 임베디드 시스템 또는 임베디드 컴퓨터를 위한 운영체제이다. 


# 컴퓨터의 구조와 성능 향상
# 프로세스와 스레드

프로그램은 저장장치에 저장된 정적인 상태이고 프로세스는 실행을 위해 메모리에 올라온 동적인 상태이다. 프로세스는 일괄 작업 방식 또는 시분할 방식으로 처리될 수 있다. 일괄 작업 방식은 여러 프로세스가 순서대로 하나씩 프로세스를 처리하는 방식으로 큐로 처리되고, 작업효율은 떨어진다. 시분할 방식은 프로세스를 여러 프로세스에 실행시간을 분배해 동시에 실행되는 것처럼 처리한다. 시분할 방식은 예외처리가 필요하다. 프로그램이 프로세스로 전환될때 `프로세스제어블록(PCB)`이 만들어진다. 프로세스제어블록에는 다음과 같은 정보가 있다. 

* 프로세스구분자(PID) : 프로세스를 구분하기 위한 값
* 메모리 관련 정보 : 메모리 위치 정보, 메모리 보호를 위한 `경계레지스터`, `한계레지스터`
* 각종 중간값 : 컨텍스트 체인지 시 사용중인 레지스터, 프로그램 카운터 

PCB는 메모리에서 운영체제 영역에 보관되며, 프로세스가 종료되면 삭제된다. 

프로세스는 프로세스 상태가 있다. 일괄작업시스템은 단순히 순서대로 **생성, 실행, 완료**이다. 시분할시스템은 **생성, 준비, 실행, 완료**이다. 시분할시스템에서 CPU 스케줄러가 실행할 프로세스의 순서를 정하는데, 실행 상태의 프로세스가 주어진 시간이 끝나면 준비 상태로 가고(`타임아웃`), 그 다음차례에 프로세스가 준비 상태에서 실행 상태로(`디스패치`) 이동한다. 이때 프로세스에게 주어지는 작업 시간을 타임 슬라이스 또는 타임 퀸텀이라고 한다. 타임아웃은 인터럽트의 일종인데 정확히 말하면 '클록으로부터의 인터럽트'이다. 

시분할시스템은 위에 4가지 상태로도 작동되지만 **대기**상태를 넣어 효율을 높일 수 있다. 대기 상태란 실행 상태에서 입출력을 요구할때 변하





프로세스의 구조는 코드영역, 데이터영역(일반 데이터영역+힙영역), 스택영역로 이루어진다. 워드를 예로 들면 프로그램은 코드영역에, 편집 중인 문서는 데이터 영역에, 운영체제가 워드를 작동하기 위해 사용하는 부가정보는 스택 영역에서 관리한다.  

||코드영역|데이터영역|스택영역|
|:---:|:---:|:---:|:---:|
|담는것|프로그램의 텍스트|변수나 파일 등|운영체제가 사용하는 부가정보|
|기능|읽기 전용|읽기/쓰기|숨김 영역|
|비고|텍스트 영역으로도 불림|일반 데이터영역,힙영역으로 나뉨||

fork() 시스템 호출은 실행 중인 프로세스를 복사하여 새로운 프로세스를 만드는 함수이다. 기존 프로세스와 복사된 프로세스는 다른 부분이 있는데 PID(자신), PPID(부모), CPID(자식)이다. fork의 장점은 다음과 같다. 
* 생성 속도가 빠르다
* 자원을 상속할때 추가 작업이 없다
* 시스템 관리를 효율적으로 할 수 있다 : 프로세스 종료시 자원 정리를 부모에게 맡김

exac() 시스템 호출은 기존 프로세스를 새로운 프로세스로 전환하는 함수이다. exac()의 목적은 프로세스의 구조를 재활용하는 것이다. 보통 fork()와 exac()을 같이 사용하는데 fork()로 구조를 만들고 exac()으로 내용만 바꾸는 것이다. exac()을 동작 과정은 코드영역, 데이터영역이 바뀌고, 스택영역이 리셋된다. 단, PID, PPID, CPID, 메모리 관련사항은 바뀌지 않지만, 그외 pc레지스터 등과 같은 레지스터들은 모두 리셋된다. 

# CPU 스케줄링

>CPU 스케줄링 알고리즘 과제(저수준 스케줄링)

'선점'은 빼앗을 수 있음을 뜻하고, '비선점'은 빼앗을 수 없음을 뜻한다. 여기서 빼앗기는 것은 CPU 점유권이다. 스케쥴은 `선점형 스케줄링`과 `비선점형 스케줄링`으로 나뉜다. 

||선점형 스케줄링|비선점형 스케줄링|
|:---:|:---:|:---:|
|작업방식|실행 상태인 작업 중단 가능|작업이 완료되기 까지 다른 작업 불가|
|장점|프로세스가 CPU를 독점 불가하여 대화형이나 시분할에 적합|CPU스케줄러의 작업량이 적고 문매교환으로 오버헤드가 적음|
|단점|문맥 교환 오버헤드|기다리는 프로세스가 많아 처리율이 떨어짐|
|사용|시분할 방식 스케줄링|일괄 작업 방식 스케줄링|
|중요도|높다|낮다|

대부분의 CPU 스케줄러는 우선순위를 사용한다. 커널 프로세스는 일반 프로세스보다 우선순위가 높다.

프로세스는 또 CPU 집중 프로세스와 입출력 집중 프로세스로 나눌 수 있다. CPU 집중 프로세스는 수학연산과 같이 CPU를 많이 사용하는 프로세스로 입출력 버스트가 많다. 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 효율이 향상한다. 

전면 프로세스는 GUI를 사용하여 사용자와 상호작용이 가능항 프

전면이 후면보다 우선순위가 높다.

다음은 우선순위로 프로세스를 정리한 것이다.
|우선순위 높음|우선순위 낮음|
|:---:|:---:|
|커널|일반|
|전면|후면|
|대화형|일괄 처리|
|입출력 집중|CPU 집중|

프로세스의 중요도는 프로세스 제어 블록에 표시되는데 이 우선순위는 준비상태의 `다중 큐`로 처리된다. 프로세스가 우선순위를 배정하는 방식은 고정 우선순위 방식과 변동 우선순위 방식으로 나뉜다. 여기서 고정되는지 변동되는지는 작업 중간에 프로세스의 우선순위를 말하는 것이다. 

대기 상태에서도 다중 큐를 사용한다. 

준비 큐는 한번에 하난의 프로세스를 꺼내어 CPU에 할당하고, 대기 큐는 여러개의 PCB를 꺼내 준비상태로 옯긴다.

스케줄링 알고리즘 종류

스케줄링 알고리즘의 평가기준은 다음과 같다.
* CPU 사용률: 전체 CPU 동작 시간 중 CPU가 사용된 시간, 100%가 이상적
* 처리량 : 단위 시간당 작업을 마친 프로세스 수
* 대기 시간: 프로세스가 작업 시작 전까지 대기하는 시간
* 응답 시간: 프로세스 시작 후 첫번째 출력또는 반응이 나올때까지 거리른 시간
* 반환시간 : 프로세스 시작 후 종료되고 자원을 반환하는 데까지 걸리는 시간, 대기시간+실행시간

평균 대기시간은 모든 모든 프로세스 대기 시간을 합한뒤 프로세스 수로 나눈 값이다. 평균 대기 시간은 알고리즘의 절대적인 성능을 보여주지는 않는다.

`FCFC(First Come First Served) 스케줄링`이란 우선순위 없이 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식이다. 








# 프로세스 동기화
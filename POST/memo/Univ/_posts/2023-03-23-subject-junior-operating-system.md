---
layout: post
title: "[3학년1학기]운영체제(작성중)"
order: 30
---

# 운영체제의 개요

컴퓨터는 크게 하드웨어와 소프트웨어로 나뉜다. 소프트웨어는 또 **응용 프로그램**과 **시스템 소프트웨어**로 나뉜다. 응용 프로그램은 특정 작업을 위해 사용하는 프로그램이고, 시스템 소프트웨어는 컴퓨터 하드웨어와 응용 프로그램을 관리하기 위한 소프트웨어이다. 시스템 소프트웨어는 또 `운영체제(OS)`와 `유틸리티`가 나뉜다. 운영체제란 컴퓨터 전체를 관리하고 운영하는 소프트웨어이다. 유틸리티란 운영체제의 작업을 보조(바이러스 검사, 디스크 조각 모음, 압축 작업 등)하는 소프트웨어이다. 운영체제는 응용 프로그램과 사용자에게 모든 컴퓨터 자원을 숨기고 



임베디드 운영체제는 CPU 성능이 낮고 메모리와 디스플레이 크기가 작은 임베디드 시스템 또는 임베디드 컴퓨터를 위한 운영체제이다. 


# 컴퓨터의 구조와 성능 향상
# 프로세스와 스레드

프로그램은 저장장치에 저장된 정적인 상태이고 프로세스는 실행을 위해 메모리에 올라온 동적인 상태이다. 프로세스는 일괄 작업 방식 또는 시분할 방식으로 처리될 수 있다. 일괄 작업 방식은 여러 프로세스가 순서대로 하나씩 프로세스를 처리하는 방식으로 큐로 처리되고, 작업효율은 떨어진다. 시분할 방식은 프로세스를 여러 프로세스에 실행시간을 분배해 동시에 실행되는 것처럼 처리한다. 시분할 방식은 예외처리가 필요하다. 프로그램이 프로세스로 전환될때 `프로세스제어블록(PCB)`이 만들어진다. 프로세스제어블록에는 다음과 같은 정보가 있다. 

* 프로세스구분자(PID) : 프로세스를 구분하기 위한 값
* 메모리 관련 정보 : 메모리 위치 정보, 메모리 보호를 위한 `경계레지스터`, `한계레지스터`
* 각종 중간값 : 컨텍스트 체인지 시 사용중인 레지스터, 프로그램 카운터 

PCB는 메모리에서 운영체제 영역에 보관되며, 프로세스가 종료되면 삭제된다. 

프로세스는 프로세스 상태가 있다. 일괄작업시스템은 단순히 순서대로 **생성, 실행, 완료**이다. 시분할시스템은 **생성, 준비, 실행, 완료**이다. 시분할시스템에서 CPU 스케줄러가 실행할 프로세스의 순서를 정하는데, 실행 상태의 프로세스가 주어진 시간이 끝나면 준비 상태로 가고(`타임아웃`), 그 다음차례에 프로세스가 준비 상태에서 실행 상태로(`디스패치`) 이동한다. 이때 프로세스에게 주어지는 작업 시간을 타임 슬라이스 또는 타임 퀸텀이라고 한다. 타임아웃은 인터럽트의 일종인데 정확히 말하면 '클록으로부터의 인터럽트'이다. 

시분할시스템은 위에 4가지 상태로도 작동되지만 **대기**상태를 넣어 효율을 높일 수 있다. 대기 상태란 실행 상태에서 입출력을 요구할때 변하





프로세스의 구조는 코드영역, 데이터영역(일반 데이터영역+힙영역), 스택영역로 이루어진다. 워드를 예로 들면 프로그램은 코드영역에, 편집 중인 문서는 데이터 영역에, 운영체제가 워드를 작동하기 위해 사용하는 부가정보는 스택 영역에서 관리한다.  

||코드영역|데이터영역|스택영역|
|:---:|:---:|:---:|:---:|
|담는것|프로그램의 텍스트|변수나 파일 등|운영체제가 사용하는 부가정보|
|기능|읽기 전용|읽기/쓰기|숨김 영역|
|비고|텍스트 영역으로도 불림|일반 데이터영역,힙영역으로 나뉨||

fork() 시스템 호출은 실행 중인 프로세스를 복사하여 새로운 프로세스를 만드는 함수이다. 기존 프로세스와 복사된 프로세스는 다른 부분이 있는데 PID(자신), PPID(부모), CPID(자식)이다. fork의 장점은 다음과 같다. 
* 생성 속도가 빠르다
* 자원을 상속할때 추가 작업이 없다
* 시스템 관리를 효율적으로 할 수 있다 : 프로세스 종료시 자원 정리를 부모에게 맡김

exac() 시스템 호출은 기존 프로세스를 새로운 프로세스로 전환하는 함수이다. exac()의 목적은 프로세스의 구조를 재활용하는 것이다. 보통 fork()와 exac()을 같이 사용하는데 fork()로 구조를 만들고 exac()으로 내용만 바꾸는 것이다. exac()을 동작 과정은 코드영역, 데이터영역이 바뀌고, 스택영역이 리셋된다. 단, PID, PPID, CPID, 메모리 관련사항은 바뀌지 않지만, 그외 pc레지스터 등과 같은 레지스터들은 모두 리셋된다. 

# CPU 스케줄링

>CPU 스케줄링 알고리즘 과제(저수준 스케줄링)

'선점'은 빼앗을 수 있음을 뜻하고, '비선점'은 빼앗을 수 없음을 뜻한다. 여기서 빼앗기는 것은 CPU 점유권이다. 스케쥴은 `선점형 스케줄링`과 `비선점형 스케줄링`으로 나뉜다. 

||선점형 스케줄링|비선점형 스케줄링|
|:---:|:---:|:---:|
|작업방식|실행 상태인 작업 중단 가능|작업이 완료되기 까지 다른 작업 불가|
|장점|프로세스가 CPU를 독점 불가하여 대화형이나 시분할에 적합|CPU스케줄러의 작업량이 적고 문매교환으로 오버헤드가 적음|
|단점|문맥 교환 오버헤드|기다리는 프로세스가 많아 처리율이 떨어짐|
|사용|시분할 방식 스케줄링|일괄 작업 방식 스케줄링|
|중요도|높다|낮다|

대부분의 CPU 스케줄러는 우선순위를 사용한다. 커널 프로세스는 일반 프로세스보다 우선순위가 높다.

프로세스는 또 CPU 집중 프로세스와 입출력 집중 프로세스로 나눌 수 있다. CPU 집중 프로세스는 수학연산과 같이 CPU를 많이 사용하는 프로세스로 입출력 버스트가 많다. 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 효율이 향상한다. 

전면 프로세스는 GUI를 사용하여 사용자와 상호작용이 가능하다.

전면이 후면보다 우선순위가 높다.

다음은 우선순위로 프로세스를 정리한 것이다.
|우선순위 높음|우선순위 낮음|
|:---:|:---:|
|커널|일반|
|전면|후면|
|대화형|일괄 처리|
|입출력 집중|CPU 집중|

프로세스의 중요도는 프로세스 제어 블록에 표시되는데 이 우선순위는 준비상태의 `다중 큐`로 처리된다. 우선순위의 개수 만큼 큐가 있으며, 해당하는 우선순위의 큐에 프로세스가 들어간다. 프로세스가 우선순위를 배정하는 방식은 고정 우선순위 방식과 변동 우선순위 방식으로 나뉜다. 이 방식은 작업 중간에 프로세스의 우선순위를 고정할지 변동할지를 말하는 것이다. 변동 우선순위 방식은 효율은 좋지만 구현하기 어렵다. 예를들어 우선순위가 낮지만 중요한 자원을 사용중일때 우선순위를 높이면 CPU를 더 자주 할당받아 작업을 빨리 끝낼 수 있다.  

대기 상태에서도 다중 큐를 사용한다. 대기 상태는 입출력을 기다리는 프로세스들이 모여있는 곳으로, 입출력 장치의 개수만큼 큐가 존재한다. 여기서 입출력 장치에는 HDD, CD-ROM, LAN 등이 있다. 준비 큐와 대기 큐의 차이점은 준비 큐는 한번에 하나의 프로세스를 꺼내어 CPU에 할당하고, 대기 큐는 여러개의 PCB를 꺼내 준비상태로 옯긴다는 것이다.

스케줄링 알고리즘 종류

스케줄링 알고리즘의 평가기준은 다음과 같다.
* CPU 사용률: 전체 CPU 동작 시간 중 CPU가 사용된 시간, 100%가 이상적
* 처리량 : 단위 시간당 작업을 마친 프로세스 수
* 대기 시간: 프로세스가 작업 시작 전까지 대기하는 시간
* 응답 시간: 프로세스 시작 후 첫번째 출력또는 반응이 나올때까지 거리른 시간
* 반환시간 : 프로세스 시작 후 종료되고 자원을 반환하는 데까지 걸리는 시간, 대기시간+실행시간

CPU 사용률과 처리량은 계산하기 어려우므로 보통 나머지 3개의 평가 방식을 사용한다. **평균 대기시간**은 모든 모든 프로세스 대기 시간을 합한뒤 프로세스 수로 나눈 값이다. 평균 대기 시간은 알고리즘의 절대적인 성능을 보여주지는 않는다.

`FCFC(First Come First Served) 스케줄링`이란 우선순위 없이 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식이다. 이 방식은 프로세스의 처리 기간이 길면 다른 프로세스들은 기다린다는 단점이 있다. 이처럼 컨베이어 벨트에 작업물이 한줄로 늘어서 앞의 작업이 오래 걸려 뒤의 작업 지연되는 것 같다하여 이를 **콘보이 효과**라고 한다. 

`SJF(Short Job Rirst)` 방식은 준비 큐에 있는 프로세스 중에서 실행시간이 가장 짧은 방식부터 CPU에 할당하는 비선점형 방식으로 **최단 작업 우선 스케줄링** 이라고도 한다. 이 방식은 콘보이 효과를 완화하여 보통 FCFC보다 평균 대기시간이 짧다. 하지만 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다는 점, 공평성에 위배되어 아사현상, 무한 봉쇄 현상을 일으킬 수 있다는 점이다. 후자에 대한 해결책으로 aging(나이먹기)가 있다. 이는 프로세스가 양보하는 상한선을 정하는 것이다. 이 스케줄링 방식은 위와 같은 문제로 잘 사용하지 않는다.

`HRN(Highest Response Ratio Next)` 스케줄링 방식은 SJF의 아사현상을 에이징으로 해결하는 비선점형 알고리즘으로 **최고 응답률 우선 스케줄링** 이라고도 한다. 이 방식은 서비스를 받기 위해 기다린 시간과 CPU 사용시간을 고려하여 스케줄링하는 방식이다. 프로세스의 우선순위를 정하는 기준은 **(대기시간+CPU사용시간)/CPU사용시간**이다. 하지만 여전히 공평성이 위배되어 많이 사용되지 않는다.

`RR(Round Robin)` 스케줄링은 프로세스에게 할당된 타임 슬라이스가 끝나면 준비 큐로 이동시키는 선점형 방식이다. 이 방식은 우선순위를 적용하지 않는 가장 단순한 스케줄링 방식이다. 이 방식은 FCFS의 평균 대기 시간보다 작거나 같은데, 만약 같으면 FCFS보다 비효율적이다. 왜냐하면 선점형 방식은 **문맥 교환 시간**이 추가되기 때문이다. 

`SRT(Shortest Remaining Time)` 스케줄링은 SJF와 RR을 혼합한 선점형 방식으로 **최소 잔류 시간 우선 스케줄링**이라고도 한다. 타임 슬라이스가 있으며, 우선순위는 *남은 작업 시간*이 가장 적은 프로세스 순으로 선택한다. 이 방식은 평균 대기 시간이 위에 방식들보다 작지만, SJF에는 없는 문맥교환시간이 추가되고, 종료시간은 예측하기 어려우며, 아사 현상이 발생한다는 단점이 있어 잘 사용되지 않는다. 다시말해 SJF와 RR의 단점을 모두 가지고 있다는 것이다.

`우선순위 스케줄링`은 어떤 기준으로 우선순위를 정하느냐에 따라 다양하게 구현이 가능하다. 이 방식은 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로 공평성을 위배하고 아사현상을 일으킨다는 공통적인 문제가 있다. 또한 우선순위를 매번 바꾸어야 하므로 오버헤드가 발생해 시스템의 효율성이 떨어진다.

`다단계 큐 스케줄링(MLQ, Multi-Level Queue)`은 우선순위에 따라 준비 큐를 여러개 사용하여 운영체제는 프로세스에 우선순위를 매겨 해당 우선순위 큐에 삽입하는 방식이다. 우선순위는 프로세스가 큐에 삽입되는 것으로 우선순위가 고정되어, 상단 큐에 모든 작업이 끝나야 다음 우선순위 큐의 작업이 시작된다. 이 방식은 선점형 방식으로 

`다단계 피드백 큐 스케줄링(MLQ, Multi-Level Feedback Queue)`은 MLQ의 문제를 보완한 방식으로 CPU를 사용한 후에는 우선순위를 낮추어 아사현상을 해결한다.(그러나 커널 프로세스가 일반 프로세스 큐에 삽입되지는 않는다) 또한 우선순위가 낮으면 타임 슬라이스를 크게하여 우선순위가 낮은 프로세스에게 실행기뢰를 확대한다. 하지만

### 인터럽트 처리

* 폴링 : 입출력이 요청되면 운영체제가 주기적으로 입출력 장치를 직접 확인해서 처리하는 방식
* 인터럽트 : 

`동기적 인터럽트`란 프로세스가 실행 중인 명령어로 인해 발생하는 인터럽트로 **사용자 인터럽트**라고도 한다. 예를들어 프로그램 상의 문제로 다른 사용자의메모리에 접근하거나 

`비동기적 인터럽트`란 실행중인 명령어와 무관하게 발생하는 인터럽트이다. 

이 인터럽트의 처리과정은 단순하다. 

1. 인터럽트가 발생하면 실행중인 프로세스는 일시 정지 상태가 되며 재시작을 위해 현재 프로세스 관련 정보를 임시로 저장한다. 
2. 인터럽트 컨트롤러가 실행되어 인터럽트 처리 순서를 결정한다. 






# 프로세스 동기화

### 프로세스 간 통신

프로세스 혹은 스레드는 독립적으로 실행된다. 스레드는 하나의 프로세스 내에서 자원을 공유하는 실행단위이고, `IPC(Inter Process Communication)`은 운영체제에 의해 프로세스 간에 데이터를 주고 받는 프로세스 간 통신이다. IPC에는 다음과 같은 종류가 았다.

* 공유메모리나 공유 파일을 이용한 통신 : 일정한 메모리 여역이나 파일을 공유하는 원시적인 방법
* 파이프를 이용한 통신 : 파이프는 운영체제가 제공하는 통신기법으로 보통 fork()로 부모-자식 간 통신에 사용된다
* 소켓을 이용한 통신 :

프로세스 간 통신을 분류

* **양방향 통신(duplex communication)** : 데이터를 양쪽으로 전송 가능, 소켓을 이용
* **반양방향 통신(hlafduplex communication)** : 데이터를 양쪽으로 전송 가능하나 동시 전송은 불가 ex)무전기
* **단방향 통신(simplex communication)** : 한쪽으로만 데이터 전송 가능, 공유 메모리나 공유 파일, 파이프를 이용

통신 구현방식에 따른 분류

* 대기가 있는 통신(동기화 통신) : 데이터가 도착할때까지 자동으로 대기 상태 ex) 전화
* 대기가 없는 통신(비동기화 통신) : 바쁜대기를 사용해 데이터가 도착했는지 여부 확인 ex) 전보

프로세스간 통신의 종류

* 파일을 이용한 통신 : 파일열기(open() 함수로 파일이 있는지, 쓰기 권한인지, 파일 기술자 fd를 반환) - 파일 읽기 쓰기(write(fd,~),read(fd,~)) - 파일 닫기(close(fd))의 과정
* 파이프를 이용한 통신 : 파일 입출력 처럼 open(), close(fd)로 통신, 단방향 통신이지만 파이프 2개 사용시 양방향 통신 가능
 - 이름 없는 파이프 : 부모와 자식 또는 같은 부모를 가진 자식 프로세스와 같이 서로 관련이 있는 프로세스 간 통신
 - 이름 있는 파이프 : FIFO를 이용
* 소켓을 이용한 통신 : 네트워킹으로 서로 다른 컴퓨터의 프로세스끼리 통신, 컴퓨터의 위치를 파악하는데 IP를 이용, 다른 컴퓨터의 프로세스를 구분하기 위해 포트번호인 TCP 이용, 서버에서 돌아가는 프로세스인 데몬도 포트번호 필요

### 공유 자원과 임계구역

`공유자원(shared resource)`이란 여러 프로세스가 공동으로 이용하는 변수,메모리,파일 등 이다. `경쟁조건(race condition)`이란 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황이다. 경쟁 조건이 발생하면 공유자원 **접근 순서**에 따라 결과가 달라질 수 있다. `임계구역(critical section)`이란 공유자원 접근 순서에 따라 실행결과가 달라지는 프로그램 영역이다. 만약 프로세스가 읽기만 한다면 공유자원이라해도 임계구역이 아니다. 만약 공유자원을 임계구역으로 지정하면 임계구역에서 프로세스의 작업을 마쳐야지 다른 프로세스가 작업을 할 수 있기 때문에 문제가 발생하지 않는다. 

임계구역과 관련된 대표적인 문제를 `생산자-소비자 문제`라고 한다. 생산자와 소비자 프로세스는 서로 독립적으로 작동하며, 버퍼에 생산자는 물건을 넣고, 소비자는 물건을 가져간다. 이때 버퍼에 담긴 물건의 개수를 저장하는 전역 변수 sum이 있다. 생산자가 물건을 담았고 sum을 바꾸기 전에 소비자가 물건을 가져가고 sum을 수정하면 문제가 발생한다. 

임계구역 문제를 위해 3가지 해결책이 있다.
* `상호배제(mutual exclusion)` : 임계구역에는 하나의 프로세스만 들어갈 수 있다. 
* `한정대기(bounding waiting)` : 어떤 프로세스가 임계구역을 무한정 사용해 다른 프로세스가 무한대기 하면 안된다. 
* `진행의 융통성(progress flexibility)` : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다. 

### 임계구역 문제 해결 방법

임계구역 문제를 해결하기 위해 기본적으로 '잠금'을 사용할 수 있다. 잠금을 공유변수로 두고 작업을 시작하기전 잠금을 true로 하고 작업이 끝나면 잠금을 false로 한다. 다른 프로세스가 접근을 하면 잠금이 false가 될떄까지 while문이 무한정 돌아간다. 이 방법의 단점은 while문 직후에 문맥교환이 일어나면 잠금이 풀리고, 다른 프로세스는 잠금이 풀리기를 기다리면서 바쁜대기를 해야한다는 것이다.

이 한정대기 문제를 해결하기 위해 잠금 공유변수를 2개를 사용하고 while문 이전에 상대방에게 잠금을 거는 방식이 있다. 하지만 이 방식도 문제가 있는데 상대방에게 잠금을 걸고 문맥교환이 일어나면 무한 대기를 한다는 것이다. 이러한 상황을 **교착상태**라고 한다.


피터슨 알고리즘은 turn이라는 공유번수를 사용한다. 이 방식은 상대에게 잠금을 걸고 turn의 값을 변경한다. 만약 문맥교환이 일어나도 while문 조건에 turn이 and로 걸려있기 때문에 

피터슨 알고리즘과 데커 알고리즘은 임계구역 해결의 세가지 조건을 모두 만족하지만 복잡하다.

세마포어 알고리즘은 위에 알고리즘보다 간단하고 사용하기 쉽다. 

```c
Semaphore(n);//n은 공유 자원 개수
P();//잠금을 수행
//(임계구역)
V();//잠금 해제와 동기화
```

### 파일, 파이프, 소켓 프로그래밍

`순차파일`은 데이터가 한줄로 저장되는 형태이다. 파일은 open(), read(), write(), close() 연산을 사용하는데 open을 통해 파일 기술자 fd를 얻고 fd를 통해 파일을 읽고 쓰고 닫는다. 이 파일을 이용해 통신을 할 수 있다. fork()를 하기전에 open()을 하여

파이프를 이용한 통신은 
---
layout: post
title: "[3학년1학기]운영체제"
order: 30
---

# Operating System(OS)

### \[OS란]

컴퓨터는 크게 하드웨어와 소프트웨어로 나뉜다. 소프트웨어는 또 **응용 프로그램**과 **시스템 소프트웨어**로 나뉜다. 응용 프로그램은 특정 작업을 위해 사용하는 프로그램이고, 시스템 소프트웨어는 컴퓨터 하드웨어와 응용 프로그램을 관리하기 위한 소프트웨어이다. 시스템 소프트웨어는 또 `운영체제(OS)`와 **유틸리티**로 나뉜다. 운영체제란 컴퓨터 자원을 효율적으로 관리하고 응용 프로그램을 실행하기 위한 환경을 제공하는 소프트웨어이다. 유틸리티란 운영체제의 작업을 보조(바이러스 검사, 디스크 조각 모음, 압축 작업 등)하는 소프트웨어이다. 운영체제는 SW와 HW의 특성을 모두 가지므로 **펌웨어(firmware)**라고 한다.

### [OS 구조]

운영체제는 다시 `Kernel`과 `Interface`로 나뉜다. 먼저 커널은 컴퓨터의 자원을 관리하는 역할을 한다. **프로세스 관리, 메모리 관리, 파일 시스템 관리, 입출력 장치 관리, 프로세스 간 통신 관리**가 커널이 하는 일이다. 인터페이스는 사용자의 명령을 커널에게 전달하고 명령을 수행한 결과를 보여주는 역할을 한다. 인터페이스는 명령줄 인터페이스(CLI)와 그래픽 인터페이스(GUI)를 포함하며, 응용 프로그램이 시스템의 기능을 사용할 수 있도록 API (Application Programming Interface)와 같은 프로그래밍 인터페이스도 제공한다. 

커널은 `시스템 호출(System Call)`이라는 함수(인터페이스)를 통해 자신의 기능을 제공한다. 시스템 호출을 통해 안전하게 자원에 접근 가능하며, 운영체제는 그외에 자원 접근을 제한하여 컴퓨터 자원을 보호한다. 그러나 만약 응용 프로그램이 운영체제의 최상위 권한 모드인 커널 모드에 진입했을 경우 시스템 호출을 거치지 않고 자원을 **직접 접근**할 수 있다.

또한 커널은 `Device Driver`라는 커널과 하드웨어 사이에 인터페이스를 통해 하드웨어를 조작한다.

### [커널의 종류]

* **단일형 구조 커널(Monolithic Architecture)** : 커널(Kernel)이 단일 모듈로 구성되어 있는 구조이다. 핵심 기능들을 모듈로 구분하지 않았기 때문에 모듈 간 통신 비용이 없고 빠르지만, 결합도가 높기 때문에 버그나 오류를 찾기 어렵고, 결함이 시스템 전체에 퍼질 수 있으며, 새로운 환경에 적용하기 어렵다는 단점이 있다.
* **계층형 구조 커널(Layered Architecture)** : 유사한 기능의 모듈들을 하나의 계층으로 묶어 계층 별로 분리한 구조이다. 
* **마이크로 구조 커널(Micro Architecture)** : 최소한의 기능(프로세스 관리, 메모리 관리, 프로세스 간 통신)만 커널이 제공하는 구조이다. 나머지 기능 모듈들은 사용자 영역에 존재한다. system call도 사용자 영역에 존재한다. 
* **가상머신(virtual machine)** : 가상머신이란 하나의 컴퓨터 시스템 내에서 다른 컴퓨터 시스템을 소프트웨어적으로 모방하여 실행하는 환경이다. 예를 들어 자바 가상 머신이 있다.

### [운영체제 종류]

* Unix : 단순하고, 이식하기 쉬운 운영체제이다. 오픈소스가 되면서 여러 버전이 나왔다. 
* Linux : 리누스 토발즈가 만든 PC에서 동작하는 유닉스 호환 커널이다.
* MacOS : 마하 커널 기반의 최초의 GUI를 도입한 운영체제
* IOS : MacOS를 수정한 OS로 모바일 전용 운영체제이다.
* Window : 마이크로소프트가 MacOS를 보고 만든 GUI 운영체제
* Android : 구글에서 개발한 모바일 전용 운영체제이다. 리눅스 커널과 자바를 사용해 호환성이 뛰어나다.

### [OS 역할]

* 자원 관리(효율성) : 컴퓨터 자원을 응용 프로그램에게 효율 적으로 분배
* 자원 보호(안정성) : 악의적이거나, 잘못된 작업에 대해 컴퓨터 자원 보호
* 하드웨어 인터페이스 제공(확장성) : CPU, 메모리, 키보드 등 하드웨어를 쉽게 사용
* 사용자 인터페이스 제공(편리성) : GUI처럼 사용자가 운영체제를 쉽게 사용

### [OS 발전과정]

1. 에니악(1940년대) : 하드 와이어링 방식으로 논리회로를 구성하는 최초의 컴퓨터로 운영체제가 없다
1. 천공카드(1950년대) : 일괄 작업 시스템 방식의 운영체제
1. 대화형 시스템(1960년대) : 키보드와 모니터 사용
1. 시분할 시스템(1960년대) : 멀티 프로그래밍으로 하나의 cpu로 여러 작업을 동시에 실행하는 것처럼
1. 분산 시스템(1970년대) : 여러 컴퓨터를 네트워크로 연결해 작업을 처리
1. 클라이언트/서버 시스템(1990년대)
1. P2P 시스템, 클라우드 컴퓨팅, 사물 인터넷(2000년대)



# Computer Structure

## [기본 지식]

컴퓨터는 필수장치인 CPU와 메인 메모리와 주변 장치인 입출력 장치, 저장장치 등으로 구성된다. 

* `CPU(중앙처리장치)` : 필수 장치
* `메인 메모리(주기억장치)` : 현재 실행 중인 프로그램과 데이터를 저장하는 휘발성 메모리(RAM)로 보통 메모리는 메인 메모리를 가리킨다.
* **입출력장치** : 입력과 출력을 담당
* **저장장치** : 데이터를 영구적으로 저장할 수 있는 비휘발성 메모리(ROM)로 용량이 크고 값이 싸지만, 메모리보다 속도가 느리다. 제2저장장치, 보조저장장치라고도 불린다.
* **메인보드** : CPU와 메모리 등의 장치를 버스로 연결하고 전원을 공급해주는 판
* **버스** : 장치들을 연결하여 데이터를 이동시키는 통로

컴퓨터에서 데이터의 표시 단위는 bit(b)이고, 8b = 1B(Byte)이다. 바이트는 B, KB, MB, GB, TB, PB 순으로 커지며 각 단위당 2^10배의 차이가 난다. 그리고 바이트의 크기를 10진법으로 알기 쉽게 표현하기 위해 대략 2^10=1024≒1000으로 계산하여 각 바이트 단위 당 1000배의 차이가 나는 것으로 표현하기도 한다.

컴퓨터는 일정한 박자인 `클록(Clock)`에 맞추어 작업을 한다. 클록에 의해 일정한 간격으로 만들어지는 틱을 펄스 또는 클록 틱이라 한다. CPU도 클록에 맞추어 작업을 하는데 헤르츠(Hz)로 CPU의 성능을 나타낼 수 있다. 헤르츠는 1초동안 몇 번의 작업이 일어났는지, 즉 몇번의 클록 틱이 발생했는지이다.  

버스는 **시스템 버스**와 **CPU 버스**로 나뉜다. 
* 시스템 버스 : 는 메모리와 주변장치를 연결하는 버스, 메인보드의 동작 속도를 나타냄, 전면버스(FSB)라고도 불림
* CPU 버스 : CPU 내부의 다양한 장치를 연결하는 버스, CPU 클록의 속도이며 FSB보다 빠름, 후면버스(BSB)로도 불림

소스코드를 컴퓨터가 이해할 수 있는 기계어로 바꾸는 작업은 크게 두 가지로 나뉘는데 **컴파일러**와 **인터프리터**이다. 컴파일은 소스코드를 컴파일하여 기계어로 변역한 싱행 파일을 만들고, 인터프리터는 실행 파일을 만들지 않고 소스 코드를 한줄씩 해석해 실행한다.

## [폰노이만 구조(Von Neumann architecture)]

`폰노이만 구조`란 CPU, 메인 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조이다. 폰 노이만 구조는 프로그램과 데이터가 같은 형태의 이진 코드로 저장장치에 저장되며, CPU가 명령어를 메모리에 가져와 실행한다는 특징이 있다.

폰 노이만 구조는 `요리사 모형`으로 설명 가능하다. 요리사 모형에는 요리사(CPU), 도마(메인 메모리), 보관창고(저장장치)가 있다. 요리사는 보관창고에서 재료를 꺼내 도마에 올리고 요리를 하며, 요리방법 결정(프로세스 관리), 도마 정리(메모리 관리), 보관창고 정리(저장장치 관리)를 한다. 만약 도마가 요리를 방해할 만큼 작으면 요리를 하는데 오래 걸리는 것처럼 메모리 크기가 일정 수준이하로 작으면 컴퓨터 작업 속도가 떨어진다.

## [CPU & 메모리]

CPU는 다음으로 구성된다.
* 산술논리 연산장치(ALU) : 산술연산(+,-,*,/)과 논리연산(AND, OR)을 수행
* 제어장치(CU) : 작업을 지시
* 레지스터(Register) : CPU 내부의 위치한 고속의 메모리로 작업에 필요한 데이터를 저장

다음은 덧셈을 하는 코드이다.
```c
int DR2=2;//메모리 100번지가 a라고 가정
int DR3=3;//메모리 120번지가 b라고 가정
int sum;//메모리 160번지가 sum이라고 가정
sum=DR2+DR3;
```
아래는 위에 코드를 어셈블리어와 유사한 코드로 바꾼 것이다.
```c
LOAD mem(100), register 2 //메모리 100번지 내용을 R2로 이동
LOAD mem(120), register 3 //메모리 120번지 내용을 R3로 이동
ADD register 5, register 2, register 3 //R2와 R3를 더한뒤 R5에 저장
MOVE register 5, mem(160) //R5의 결과를 메모리 160번지에 저장
```

레지스터에는 여러 종류가 있다.
* **사용자 가시 레지스터** : 산술논리 연산장치가 이용하며, 사용자 프로그램에 의해서 값이 변경됨
    * `데이터 레지스터(DR)` : 메모리에서 가져온 데이터를 임시 저장한다. CPU에 있는 대부분의 레지스터로 일반 레지스터 또는 범용 레지스터로 불린다.
    * `주소 레지스터(AR)` : 데이터나 명령어가 저장된 메모리의 주소를 저장한다.
* **특수 레지스터** : 사용자가 임의로 변경할 수 없음
    * `프로그램 카운터(PC)` : 다음에 실행할 명령어의 주소를 저장한다. 명령어 카운터 라고도 불린다. 
    * `명령어 레지스터(IR)` : 현재 실행중인 명령어를 저장한다. 제어장치가 IR의 데이터를 해석후 외부 장치에 신호를 보낸다.
    * `메모리 주소 레지스터(MAR)` : 메모리 관리자가 메모리에서 가져오거나 보낼 데이터의 주소를 저장
    * `메모리 버퍼 레지스터(MBR)` : 메모리 관리자가 MAR에 저장된 주소에서 가져오거나 보낼 데이터를 임시저장
    * `프로그램 상태 레지스터(PSR)` : if문 분기에 사용되며, 플래그 레지스터, 상태 레지스터, 컨디션 레지스터라고도 불린다.

시스템 버스에는 3가지 종류가 있다. 
* 제어 버스(control bus) : CPU의 제어장치가 어떤 장치에게 내린 제어 신호가 이동하는 통로이다. 신호를 받은 장치는 작업을 완료했거나 오류가 발생했다는 결과를 CPU로 전송해야하기 때문에 양방향이다.
* 주소 버스(address bus) : MAR과 연결된 버스로 단방향이다.
* 데이터 버스(data bus) : MBR과 연결된 버스로 양방향이다.

버스의 **대역폭(bandwidth)** 한번에 전달할 수 있는 데이터의 크기이다. 일반적으로 32bit CPU, 64bit CPU가 있다. 그리고 CPU가 한번에 처리할 수 있는 데이터의 최대크기를 **워드**라고한다. 예를들어 32bit CPU에서는 1워드는 32bit이다. 64bit CPU가 한번에 처리할 수 있는 데이터가 더 크기 때문에 64bit CPU가 더 빠르다 

다음은 메모리의 종류이다.
* 휘발성 RAM(volatility RAM)
    * DRAM(Dynamic RAM) : 전력이 공급되도 일정 시간이 지나면 사라져 재생이 필요
    * SRAM(Static RAM) : 전력이 공급되는 동안 데이터 보관
    * SDRAM(Synchronous Dynamic RAM) : 클록틱 발생마다 데이터를 저장하는 동기 DRAM
    * DDR(Double Data Rate) SDRAM : SDRAM의 입출력 속도를 높인것
* 비휘발성 RAM(non-volatility RAM)
    * 플래시 메모리 : 전력없이 데이터 보관. 각 소자당 최대 사용횟수 있음 e.g. sd 카드, usb
    * FRAM
    * PRAM
    * SSD : 빠른 속도, 저전력, 높은 내구성으로 하드디스크를 대신하여 쓰임
* ROM : 데이터를 한번 저장하면 바꿀 수 없어 바이오스를 저장하는 용도
    * 마스크 롬 : 데이터를 지우거나 쓸 수 없음
    * PROM : 전용 기계를 사용해 한번만 저장 가능
    * EPROM : 플래시 메모리처럼 사용가능하나 가격이 비쌈

메모리는 운영체제 영역과 사용자 영역으로 나뉜다. 프로그램은 각자의 사용자 영역을 사용하는데 어떤 프로그램이 다른 프로그램의 사용자 영역을 침범하지 않도록 **메모리 보호**를 해야한다. 프로그램이 CPU를 사용중이면, 운영체제의 작업이 중단되므로 하드웨어의 도움을 받아야한다. 이때 `경계 레지스터`와 `한계 레지스터`를 사용한다. 경계 레지스터는 현재 진행 중인 메모리의 시작 주소를 저장하고, 한계 레지스터에 마지막 주소까지의 차이, 즉 크기를 저장한다. 만약 작업 중에 두 레지스터 값을 벗어났으면 CPU는 작업을 중단시키고 운영체제에게 인터럽트 신호를 보내 운영체제는 해당 작업을 강제 종료시킨다.

운영체제 또한 응용 프로그램처럼 메모리에 올려서 실행을 한다. 이때 운영체제를 하드디스크에서 메모리에 올리는 과정을 `부팅`이라고 하고, 이를 ROM에 저장된 `바이오스`가 실행시킨다. 바이오스는 더불어 CPU, 메모리, 하드디스크 등 하드웨어가 정상적으로 작동하는지 확인한다. 하드웨어 점검을 완료하면 하드디스크에 **마스터 부트 레코드(MBR)**을 메모리로 가져와 실행한다. MBR에는 운영체제를 실행하기 위한 `부트 스트랩`이 저장되어 있다. 

## [컴퓨터 성능 향상 기술]

* `buffer` : 일정량의 데이터를 모아서 옮겨 두 장치의 속도 차이를 완화하는 장치이다.
* `SPOOL` : 입출력 작업을 대기열 형태로 처리하여 CPU와 입출력 장치가 독립적으로 동작하게하는 소프트웨어적인 버퍼이다. 
* `cache` : CPU가 앞으로 사용할 것으로 예상되는 메모리의 데이터를 **미리 가져와(prefetch)** 메모리와 CPU간의 속도 차이를 완화하는 임시저장소이자 버퍼의 일종이다. 캐시는 CPU 내부 버스 속도로 작동하므로 빠르다. 캐시의 데이터를 CPU가 실제로 사용하면 **cache hit**라고 하며, 사용하지 않았을 때는 **cache miss**라고 한다. 캐시 히트가 되는 비율인 캐시 적중률은 보통 90%이다. 캐시 적중률을 높이는 방법은 캐시의 크기를 키우거나, 지역성 이론에 따라 가까운 데이터를 가져오는 법이 있다. 또한 캐시가 데이터를 가져왔는데 메모리에서 변경이 될때 이를 반영해야한다. 여기에 **즉시쓰기**와 **지연쓰기** 방법이 있다. 즉시쓰기 방법은 메모리의 최신값이 항상 유지되지만 빈번한 데이터 전송으로 성능이 느리다는 단점이 있다. 지연쓰기는 변경된 내용들을 모아 주기적으로 반영하는 방법이다. 즉시쓰기에 비해 성능은 향상되지만 데이터의 불일치가 발생할 수 있다는 단점이 있다. 캐시는 두개의 레벨로 나뉘는데 메모리에서 어떤 자료든 상관없이 가져오는 **일반 캐시(L2 캐시)**와 명령어와 데이터를 구분하여 저장하는 **특수 캐시(L1 캐시)**이다. 특수 캐시는 명령어 캐시와 데이터 캐시로 나뉘며 각각 IR과 DR에 연결되어 있다.
* `저장장치 계층구조(storage hierarchy)` : 저장장치들을 속도 순으로 배치시킨 구조이다. 속도가 가장 빠른 저장장치는 CPU 근처에 배치되며 *레지스터-캐시-메모리-저장장치* 순으로 배치된다.  보통 저장장치의 속도가 빠르면 가격이 비싸 용량이 적다. 이 구조를 사용하면 속도는 레지스터처럼 빠르면서 용량은 저장장치처럼 크게 컴퓨터를 동작시킬 수 있다. 문제는 중복되는 데이터의 일관성을 유지시키는 것이다. 데이터 일관성이 틀려지는 경우는 지연쓰기를 사용하거나, 동시에 같은 데이터에 같은 프로세스가 접근하거나, 갑자기 전원이 꺼지거나, 버퍼를 비우지 않았는데 하드웨어를 제거하는 경우이다.
* `interrupt` : CPU의 작업과 외부장치의 작업을 독립적으로 운영하는 방식이다. 과거에는 CPU가 작업을 일일이 지시하는 **polling** 방식을 사용했기 때문에 CPU의 효율이 떨어졌다. interrupt 방식의 과정은 외부장치에게 명령을 보내면 장치가 독립적으로 작업을 실행하고 그 결과를 CPU에게 완료 신호인 interrupt를 보내는 것이다. CPU는 interrupt를 받으면 작업을 중단하고 이벤트를 처리한다. interrupt가 자주 발생되면 비효율적이므로 interrupt의 배열인 **interrupt vector**를 사용한다. 또한 interrupt를 어떤 장치가 보냈는지에 대한 장치 고유 번호인 **interrupt number**가 있다. 이는 운영체제마다 다르며 window에서는 인터럽트 번호를 IRQ라고 부르며 키보트는 1번, 마우스는 12번 등으로 구분한다. 
* `직접 메모리 접근` : 




# Process, Thread

프로그램은 저장장치에 저장된 정적인 상태이고 프로세스는 실행을 위해 메모리에 올라온 동적인 상태이다. 프로세스는 일괄 작업 방식 또는 시분할 방식으로 처리될 수 있다. 일괄 작업 방식은 여러 프로세스가 순서대로 하나씩 프로세스를 처리하는 방식으로 큐로 처리되고, 작업효율은 떨어진다. 시분할 방식은 프로세스를 여러 프로세스에 실행시간을 분배해 동시에 실행되는 것처럼 처리한다. 시분할 방식은 예외처리가 필요하다. 프로그램이 프로세스로 전환될때 `프로세스제어블록(PCB)`이 만들어진다. 프로세스제어블록에는 다음과 같은 정보가 있다. 

* 프로세스구분자(PID) : 프로세스를 구분하기 위한 값
* 메모리 관련 정보 : 메모리 위치 정보, 메모리 보호를 위한 `경계레지스터`, `한계레지스터`
* 각종 중간값 : 컨텍스트 체인지 시 사용중인 레지스터, 프로그램 카운터 

PCB는 메모리에서 운영체제 영역에 보관되며, 프로세스가 종료되면 삭제된다. 

프로세스는 프로세스 상태가 있다. 일괄작업시스템은 단순히 순서대로 **생성, 실행, 완료**이다. 시분할시스템은 **생성, 준비, 실행, 완료**이다. 시분할시스템에서 CPU 스케줄러가 실행할 프로세스의 순서를 정하는데, 실행 상태의 프로세스가 주어진 시간이 끝나면 준비 상태로 가고(`타임아웃`), 그 다음차례에 프로세스가 준비 상태에서 실행 상태로(`디스패치`) 이동한다. 이때 프로세스에게 주어지는 작업 시간을 타임 슬라이스 또는 타임 퀸텀이라고 한다. 타임아웃은 인터럽트의 일종인데 정확히 말하면 '클록으로부터의 인터럽트'이다. 

시분할시스템은 위에 4가지 상태로도 작동되지만 **대기**상태를 넣어 효율을 높일 수 있다. 대기 상태란 실행 상태에서 입출력을 요구할때 변하





프로세스의 구조는 코드영역, 데이터영역(일반 데이터영역+힙영역), 스택영역로 이루어진다. 워드를 예로 들면 프로그램은 코드영역에, 편집 중인 문서는 데이터 영역에, 운영체제가 워드를 작동하기 위해 사용하는 부가정보는 스택 영역에서 관리한다.  

||코드영역|데이터영역|스택영역|
|:---:|:---:|:---:|:---:|
|담는것|프로그램의 텍스트|변수나 파일 등|운영체제가 사용하는 부가정보|
|기능|읽기 전용|읽기/쓰기|숨김 영역|
|비고|텍스트 영역으로도 불림|일반 데이터영역,힙영역으로 나뉨||

fork() 시스템 호출은 실행 중인 프로세스를 복사하여 새로운 프로세스를 만드는 함수이다. 기존 프로세스와 복사된 프로세스는 다른 부분이 있는데 PID(자신), PPID(부모), CPID(자식)이다. fork의 장점은 다음과 같다. 
* 생성 속도가 빠르다
* 자원을 상속할때 추가 작업이 없다
* 시스템 관리를 효율적으로 할 수 있다 : 프로세스 종료시 자원 정리를 부모에게 맡김

exac() 시스템 호출은 기존 프로세스를 새로운 프로세스로 전환하는 함수이다. exac()의 목적은 프로세스의 구조를 재활용하는 것이다. 보통 fork()와 exac()을 같이 사용하는데 fork()로 구조를 만들고 exac()으로 내용만 바꾸는 것이다. exac()을 동작 과정은 코드영역, 데이터영역이 바뀌고, 스택영역이 리셋된다. 단, PID, PPID, CPID, 메모리 관련사항은 바뀌지 않지만, 그외 pc레지스터 등과 같은 레지스터들은 모두 리셋된다. 

# CPU Scheduling

>CPU 스케줄링 알고리즘 과제(저수준 스케줄링)

'선점'은 빼앗을 수 있음을 뜻하고, '비선점'은 빼앗을 수 없음을 뜻한다. 여기서 빼앗기는 것은 CPU 점유권이다. 스케쥴은 `선점형 스케줄링`과 `비선점형 스케줄링`으로 나뉜다. 

||선점형 스케줄링|비선점형 스케줄링|
|:---:|:---:|:---:|
|작업방식|실행 상태인 작업 중단 가능|작업이 완료되기 까지 다른 작업 불가|
|장점|프로세스가 CPU를 독점 불가하여 대화형이나 시분할에 적합|CPU스케줄러의 작업량이 적고 문매교환으로 오버헤드가 적음|
|단점|문맥 교환 오버헤드|기다리는 프로세스가 많아 처리율이 떨어짐|
|사용|시분할 방식 스케줄링|일괄 작업 방식 스케줄링|
|중요도|높다|낮다|

대부분의 CPU 스케줄러는 우선순위를 사용한다. 커널 프로세스는 일반 프로세스보다 우선순위가 높다.

프로세스는 또 CPU 집중 프로세스와 입출력 집중 프로세스로 나눌 수 있다. CPU 집중 프로세스는 수학연산과 같이 CPU를 많이 사용하는 프로세스로 입출력 버스트가 많다. 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 효율이 향상한다. 

전면 프로세스는 GUI를 사용하여 사용자와 상호작용이 가능하다.

전면이 후면보다 우선순위가 높다.

다음은 우선순위로 프로세스를 정리한 것이다.
|우선순위 높음|우선순위 낮음|
|:---:|:---:|
|커널|일반|
|전면|후면|
|대화형|일괄 처리|
|입출력 집중|CPU 집중|

프로세스의 중요도는 프로세스 제어 블록에 표시되는데 이 우선순위는 준비상태의 `다중 큐`로 처리된다. 우선순위의 개수 만큼 큐가 있으며, 해당하는 우선순위의 큐에 프로세스가 들어간다. 프로세스가 우선순위를 배정하는 방식은 고정 우선순위 방식과 변동 우선순위 방식으로 나뉜다. 이 방식은 작업 중간에 프로세스의 우선순위를 고정할지 변동할지를 말하는 것이다. 변동 우선순위 방식은 효율은 좋지만 구현하기 어렵다. 예를들어 우선순위가 낮지만 중요한 자원을 사용중일때 우선순위를 높이면 CPU를 더 자주 할당받아 작업을 빨리 끝낼 수 있다.  

대기 상태에서도 다중 큐를 사용한다. 대기 상태는 입출력을 기다리는 프로세스들이 모여있는 곳으로, 입출력 장치의 개수만큼 큐가 존재한다. 여기서 입출력 장치에는 HDD, CD-ROM, LAN 등이 있다. 준비 큐와 대기 큐의 차이점은 준비 큐는 한번에 하나의 프로세스를 꺼내어 CPU에 할당하고, 대기 큐는 여러개의 PCB를 꺼내 준비상태로 옯긴다는 것이다.

스케줄링 알고리즘 종류

스케줄링 알고리즘의 평가기준은 다음과 같다.
* CPU 사용률: 전체 CPU 동작 시간 중 CPU가 사용된 시간, 100%가 이상적
* 처리량 : 단위 시간당 작업을 마친 프로세스 수
* 대기 시간: 프로세스가 작업 시작 전까지 대기하는 시간
* 응답 시간: 프로세스 시작 후 첫번째 출력또는 반응이 나올때까지 거리른 시간
* 반환시간 : 프로세스 시작 후 종료되고 자원을 반환하는 데까지 걸리는 시간, 대기시간+실행시간

CPU 사용률과 처리량은 계산하기 어려우므로 보통 나머지 3개의 평가 방식을 사용한다. **평균 대기시간**은 모든 모든 프로세스 대기 시간을 합한뒤 프로세스 수로 나눈 값이다. 평균 대기 시간은 알고리즘의 절대적인 성능을 보여주지는 않는다.

`FCFC(First Come First Served) 스케줄링`이란 우선순위 없이 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식이다. 이 방식은 프로세스의 처리 기간이 길면 다른 프로세스들은 기다린다는 단점이 있다. 이처럼 컨베이어 벨트에 작업물이 한줄로 늘어서 앞의 작업이 오래 걸려 뒤의 작업 지연되는 것 같다하여 이를 **콘보이 효과**라고 한다. 

`SJF(Short Job Rirst)` 방식은 준비 큐에 있는 프로세스 중에서 실행시간이 가장 짧은 방식부터 CPU에 할당하는 비선점형 방식으로 **최단 작업 우선 스케줄링** 이라고도 한다. 이 방식은 콘보이 효과를 완화하여 보통 FCFC보다 평균 대기시간이 짧다. 하지만 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다는 점, 공평성에 위배되어 아사현상, 무한 봉쇄 현상을 일으킬 수 있다는 점이다. 후자에 대한 해결책으로 aging(나이먹기)가 있다. 이는 프로세스가 양보하는 상한선을 정하는 것이다. 이 스케줄링 방식은 위와 같은 문제로 잘 사용하지 않는다.

`HRN(Highest Response Ratio Next)` 스케줄링 방식은 SJF의 아사현상을 에이징으로 해결하는 비선점형 알고리즘으로 **최고 응답률 우선 스케줄링** 이라고도 한다. 이 방식은 서비스를 받기 위해 기다린 시간과 CPU 사용시간을 고려하여 스케줄링하는 방식이다. 프로세스의 우선순위를 정하는 기준은 **(대기시간+CPU사용시간)/CPU사용시간**이다. 하지만 여전히 공평성이 위배되어 많이 사용되지 않는다.

`RR(Round Robin)` 스케줄링은 프로세스에게 할당된 타임 슬라이스가 끝나면 준비 큐로 이동시키는 선점형 방식이다. 이 방식은 우선순위를 적용하지 않는 가장 단순한 스케줄링 방식이다. 이 방식은 FCFS의 평균 대기 시간보다 작거나 같은데, 만약 같으면 FCFS보다 비효율적이다. 왜냐하면 선점형 방식은 **문맥 교환 시간**이 추가되기 때문이다. 

`SRT(Shortest Remaining Time)` 스케줄링은 SJF와 RR을 혼합한 선점형 방식으로 **최소 잔류 시간 우선 스케줄링**이라고도 한다. 타임 슬라이스가 있으며, 우선순위는 *남은 작업 시간*이 가장 적은 프로세스 순으로 선택한다. 이 방식은 평균 대기 시간이 위에 방식들보다 작지만, SJF에는 없는 문맥교환시간이 추가되고, 종료시간은 예측하기 어려우며, 아사 현상이 발생한다는 단점이 있어 잘 사용되지 않는다. 다시말해 SJF와 RR의 단점을 모두 가지고 있다는 것이다.

`우선순위 스케줄링`은 어떤 기준으로 우선순위를 정하느냐에 따라 다양하게 구현이 가능하다. 이 방식은 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로 공평성을 위배하고 아사현상을 일으킨다는 공통적인 문제가 있다. 또한 우선순위를 매번 바꾸어야 하므로 오버헤드가 발생해 시스템의 효율성이 떨어진다.

`다단계 큐 스케줄링(MLQ, Multi-Level Queue)`은 우선순위에 따라 준비 큐를 여러개 사용하여 운영체제는 프로세스에 우선순위를 매겨 해당 우선순위 큐에 삽입하는 방식이다. 우선순위는 프로세스가 큐에 삽입되는 것으로 우선순위가 고정되어, 상단 큐에 모든 작업이 끝나야 다음 우선순위 큐의 작업이 시작된다. 이 방식은 선점형 방식으로 

`다단계 피드백 큐 스케줄링(MLQ, Multi-Level Feedback Queue)`은 MLQ의 문제를 보완한 방식으로 CPU를 사용한 후에는 우선순위를 낮추어 아사현상을 해결한다.(그러나 커널 프로세스가 일반 프로세스 큐에 삽입되지는 않는다) 또한 우선순위가 낮으면 타임 슬라이스를 크게하여 우선순위가 낮은 프로세스에게 실행기뢰를 확대한다. 하지만

### 인터럽트 처리

* 폴링 : 입출력이 요청되면 운영체제가 주기적으로 입출력 장치를 직접 확인해서 처리하는 방식
* 인터럽트 : 

`동기적 인터럽트`란 프로세스가 실행 중인 명령어로 인해 발생하는 인터럽트로 **사용자 인터럽트**라고도 한다. 예를들어 프로그램 상의 문제로 다른 사용자의메모리에 접근하거나 

`비동기적 인터럽트`란 실행중인 명령어와 무관하게 발생하는 인터럽트이다. 

이 인터럽트의 처리과정은 단순하다. 

1. 인터럽트가 발생하면 실행중인 프로세스는 일시 정지 상태가 되며 재시작을 위해 현재 프로세스 관련 정보를 임시로 저장한다. 
2. 인터럽트 컨트롤러가 실행되어 인터럽트 처리 순서를 결정한다. 






# 프로세스 동기화

### 프로세스 간 통신

프로세스 혹은 스레드는 독립적으로 실행된다. 스레드는 하나의 프로세스 내에서 자원을 공유하는 실행단위이고, `IPC(Inter Process Communication)`은 운영체제에 의해 프로세스 간에 데이터를 주고 받는 프로세스 간 통신이다. IPC에는 다음과 같은 종류가 았다.

* 공유메모리나 공유 파일을 이용한 통신 : 일정한 메모리 여역이나 파일을 공유하는 원시적인 방법
* 파이프를 이용한 통신 : 파이프는 운영체제가 제공하는 통신기법으로 보통 fork()로 부모-자식 간 통신에 사용된다
* 소켓을 이용한 통신 :

프로세스 간 통신을 분류

* **양방향 통신(duplex communication)** : 데이터를 양쪽으로 전송 가능, 소켓을 이용
* **반양방향 통신(hlafduplex communication)** : 데이터를 양쪽으로 전송 가능하나 동시 전송은 불가 ex)무전기
* **단방향 통신(simplex communication)** : 한쪽으로만 데이터 전송 가능, 공유 메모리나 공유 파일, 파이프를 이용

통신 구현방식에 따른 분류

* 대기가 있는 통신(동기화 통신) : 데이터가 도착할때까지 자동으로 대기 상태 ex) 전화
* 대기가 없는 통신(비동기화 통신) : 바쁜대기를 사용해 데이터가 도착했는지 여부 확인 ex) 전보

프로세스간 통신의 종류

* 파일을 이용한 통신 : 파일열기(open() 함수로 파일이 있는지, 쓰기 권한인지, 파일 기술자 fd를 반환) - 파일 읽기 쓰기(write(fd,~),read(fd,~)) - 파일 닫기(close(fd))의 과정
* 파이프를 이용한 통신 : 파일 입출력 처럼 open(), close(fd)로 통신, 단방향 통신이지만 파이프 2개 사용시 양방향 통신 가능
 - 이름 없는 파이프 : 부모와 자식 또는 같은 부모를 가진 자식 프로세스와 같이 서로 관련이 있는 프로세스 간 통신
 - 이름 있는 파이프 : FIFO를 이용
* 소켓을 이용한 통신 : 네트워킹으로 서로 다른 컴퓨터의 프로세스끼리 통신, 컴퓨터의 위치를 파악하는데 IP를 이용, 다른 컴퓨터의 프로세스를 구분하기 위해 포트번호인 TCP 이용, 서버에서 돌아가는 프로세스인 데몬도 포트번호 필요

### 공유 자원과 임계구역

`공유자원(shared resource)`이란 여러 프로세스가 공동으로 이용하는 변수,메모리,파일 등 이다. `경쟁조건(race condition)`이란 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황이다. 경쟁 조건이 발생하면 공유자원 **접근 순서**에 따라 결과가 달라질 수 있다. `임계구역(critical section)`이란 공유자원 접근 순서에 따라 실행결과가 달라지는 프로그램 영역이다. 만약 프로세스가 읽기만 한다면 공유자원이라해도 임계구역이 아니다. 만약 공유자원을 임계구역으로 지정하면 임계구역에서 프로세스의 작업을 마쳐야지 다른 프로세스가 작업을 할 수 있기 때문에 문제가 발생하지 않는다. 

임계구역과 관련된 대표적인 문제를 `생산자-소비자 문제`라고 한다. 생산자와 소비자 프로세스는 서로 독립적으로 작동하며, 버퍼에 생산자는 물건을 넣고, 소비자는 물건을 가져간다. 이때 버퍼에 담긴 물건의 개수를 저장하는 전역 변수 sum이 있다. 생산자가 물건을 담았고 sum을 바꾸기 전에 소비자가 물건을 가져가고 sum을 수정하면 문제가 발생한다. 

임계구역 문제를 위해 3가지 해결책이 있다.
* `상호배제(mutual exclusion)` : 임계구역에는 하나의 프로세스만 들어갈 수 있다. 
* `한정대기(bounding waiting)` : 어떤 프로세스가 임계구역을 무한정 사용해 다른 프로세스가 무한대기 하면 안된다. 
* `진행의 융통성(progress flexibility)` : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다. 

### 임계구역 문제 해결 방법

임계구역 문제를 해결하기 위해 기본적으로 '잠금'을 사용할 수 있다. 잠금을 공유변수로 두고 작업을 시작하기전 잠금을 true로 하고 작업이 끝나면 잠금을 false로 한다. 다른 프로세스가 접근을 하면 잠금이 false가 될떄까지 while문이 무한정 돌아간다. 이 방법의 단점은 while문 직후에 문맥교환이 일어나면 잠금이 풀리고, 다른 프로세스는 잠금이 풀리기를 기다리면서 바쁜대기를 해야한다는 것이다.

이 한정대기 문제를 해결하기 위해 잠금 공유변수를 2개를 사용하고 while문 이전에 상대방에게 잠금을 거는 방식이 있다. 하지만 이 방식도 문제가 있는데 상대방에게 잠금을 걸고 문맥교환이 일어나면 무한 대기를 한다는 것이다. 이러한 상황을 **교착상태**라고 한다.


피터슨 알고리즘은 turn이라는 공유번수를 사용한다. 이 방식은 상대에게 잠금을 걸고 turn의 값을 변경한다. 만약 문맥교환이 일어나도 while문 조건에 turn이 and로 걸려있기 때문에 

피터슨 알고리즘과 데커 알고리즘은 임계구역 해결의 세가지 조건을 모두 만족하지만 복잡하다.

```c
void process1(){
    lock1=true;
    while(lock2==2){
        lock1=false;
        while(tuen==2);
        lock1=true;
    }
}

```

세마포어 알고리즘은 위에 알고리즘보다 간단하고 사용하기 쉽다. 하지만 사용자의 실수로 아래와 같이 

```c
Semaphore(n);//n은 공유 자원 개수
P();//잠금을 수행
//(임계구역)
V();//잠금 해제와 동기화(대기중인 프로세슷에게 wake_up()신호를 보냄)
```

### 파일, 파이프, 소켓 프로그래밍

`순차파일`은 데이터가 한줄로 저장되는 형태이다. 파일은 open(), read(), write(), close() 연산을 사용하는데 open을 통해 파일 기술자 fd를 얻고 fd를 통해 파일을 읽고 쓰고 닫는다. 이 파일을 이용해 통신을 할 수 있다. fork()를 하기전에 open()을 하여

파이프를 이용한 통신은 




# 교착상태(deadlock)

`교착상태(deadlock)`란 다른 작업이 끝나기만을 기다리며 작업을 더이상 진행하지 못하는 상태

아사현상과 deadlock의 차이는 아사현상은 알고리즘의 문제로 발생하는 반면, deadlock은 자연스럽게 발생하는 현상이다.

교착상태 방생 원인은 다음과 같다.
* 다른 프로세스와 공유할 수 없는 **시스템 자원**을 사용
* 임계구역에서 **잠금**을 사용할때
* 데이터베이스에서 데이터 일관성이 깨진 경우

`자원할당 그래프`는 프로세스가 사용중인 자원, 기다리는 자원을 방향성 있는 그래프로 표현한 것이다. 프로세스는 원으로, 자원은 사각형으로, 자원을 사용중인 경우 자원에서 프로세스로 화살표를, 자원을 기다리른 경우 프로세스에서 자원으로 화살표(점선)로 그린다.

여러 프로세스가 동시에 사용하는 자원을 **다중자원**이라하며, 한 자원에서 여러 프로세스에 화살표로 가리킨다. 

교착상태는 `식사하는 철학자 문제`로 설명할 수 있다. 4개의 철학자(프로세스)가 둥근 식탁에 앉아 있고, 그위에 4개의 포크(자원)이 있다. 이때 모든 철학자가 동시에 자신의 왼쪽 포크를 잡고, 오른쪽 포크를 잡아야 식사를 할 수 있다. 포크는 4개 밖에 없기 때문에 각 철학자는 왼쪽 포크를 잡고 오른쪽 포크를 잡지 못해 굶어 죽는다

교착상태가 발생하는 필요조건은 다음과 같다. 4가지를 모두 만족해야 교착상태가 발생한다.
* 상호배제 : 철학자는 포크를 공유할 수 없음
* 비선점 : 다른 철학자의 포크를 뺏을 수 없음
* 점유와 대기 : 철학자는 포크를 잡고 다른 포크를 기다리는 상태
* 원형대기 : 포크를 잡고 있고, 포크를 기다리는 철학자는 식탁에 원으로 앉아 있어야함

## [교착상태 해결]

교착상태를 해결하는 방법은 4가지가 있다.
* `예방` : 교착상태의 4가지 조건을 사전에 예방하는 것이다. 실효성이 떨어진다.
    - **상호배제 예방** : 모든 자원을 공유할 수 있게한다. 하지만 임계구역을 보호하지 못한다.
    - **비선점 예방** : 모든 자원을 뺏을 수 있게한다. 하지만 아사현상을 일으킬 수 있다.
    - **점유와 대기 예방** : 필요한 자원을 모두 할당받을 수 없으면, 아예 할당을 받지 않는 것이다. 이 방법은 프로세스가 필요한 자원을 파악하기 어렵고, 자원의 활용성이 떨어지며, 많은 자원이 필요한 프로세스는 아사현상이 발생할 수 있으며, 일괄 작업 방식으로 처리된다는 단점이 있다. 
    - **원형 대기 예방** : 자원에 번호를 붙여 점유 중인 자원보다 번호가 큰 자원만 할당받을 수 있게한다. 하지만 자원의 번호에 따라 사용하지 못하는 자원이 생겨 유연성이 떨어지며, 자원 번호를 어떻게 부여할지 결정하기 어렵다는 문제가 있다.
* `회피` : 안정상태이면 자원을 할당하고 불안정상태이면 할당을 하지 않는다. 실효성이 떨어진다.
    - `은행원 알고리즘` : 자원 할당을 은행의 대출에 대응하는 방법이다. 이 알고리즘에서 사용하는 변수는 Total(전체자원), Available(가용자원), Max(최대자원), Allocation(할당자원), Expect(기대자원=최대자원-할당자원)이고 각 프로세스는 운영체제에게 Max값을 알려준다. 안정상태는 기대자원≤가용자원인 경우가 한 번 이상인 경우이다. 그러나 프로세스가 자원의 개수를 파악해야하고, 시스템의 전체 자원 수가 고정적이지 않으며, 자원이 낭비된다는 단점으로 사용되지 않는다.
* `검출 & 회복` : 자원할당 그래프를 모니터링하면서 교착상태가 발생하면 회복한다. **현실적인 해결책이다.**
    - **교착상태 검출(타임아웃)** : 작업이 일정시간동안 진행되지 않으면 교착상태로 처리한다. 가벼운 교착 상태 검출이라고도 한다. 단점은 엉뚱한 프로세스가 강제 종료될 수 있다는 점, 모든 시스템에 적용할 수 없다는 점(e.g. 네트워크로 연결된 분산 데이터베이스, 안정성이 요구되는 시스템)이 있다. 
    - **교착상태 검출(자원할당그래프)** : 자원할당 그래프를 이용해 사이클을 존재하는지 확인하는 방식이다. 문제는 사이클이 있다해도 다중자원을 사용하는 경우 교착상태가 아닐 수 있으며, 사이클을 검사하는 과정에서 오버헤드가 발생할 수 있다.
    - 교착상태 회복(모든 자원 종료) : 교착상태를 일으킨 모든 자원을 강제 종료한다. 그후 프로세스를 순차적으로 실행해야한다.


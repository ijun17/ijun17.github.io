---
layout: post
title: "[3학년1학기]운영체제(작성중)"
order: 30
---

# 운영체제의 개요

임베디드 운영체제는 CPU 성능이 낮고 메모리와 디스플레이 크기가 작은 임베디드 시스템을 위한 운영체제이다. 


# 컴퓨터의 구조와 성능 향상
# 프로세스와 스레드

프로그램은 저장장치에 저장된 정적인 상태이고 프로세스는 실행을 위해 메모리에 올라온 동적인 상태이다. 프로세스는 일괄 작업 방식 또는 시분할 방식으로 처리될 수 있다. 일괄 작업 방식은 여러 프로세스가 순서대로 하나씩 프로세스를 처리하는 방식으로 큐로 처리되고, 작업효율은 떨어진다. 시분할 방식은 프로세스를 여러 프로세스에 실행시간을 분배해 동시에 실행되는 것처럼 처리한다. 시분할 방식은 예외처리가 필요하다. 프로그램이 프로세스로 전환될때 `프로세스제어블록(PCB)`이 만들어진다. 프로세스제어블록에는 다음과 같은 정보가 있다. 

* 프로세스구분자(PID) : 프로세스를 구분하기 위한 값
* 메모리 관련 정보 : 메모리 위치 정보, 메모리 보호를 위한 `경계레지스터`, `한계레지스터`
* 각종 중간값 : 컨텍스트 체인지 시 사용중인 레지스터, 프로그램 카운터 

PCB는 메모리에서 운영체제 영역에 보관되며, 프로세스가 종료되면 삭제된다. 

프로세스는 프로세스 상태가 있다. 일괄작업시스템은 단순히 순서대로 **생성, 실행, 완료**이다. 시분할시스템은 **생성, 준비, 실행, 완료**이다. 시분할시스템에서 CPU 스케줄러가 실행할 프로세스의 순서를 정하는데, 실행 상태의 프로세스가 주어진 시간이 끝나면 준비 상태로 가고(`타임아웃`), 그 다음차례에 프로세스가 준비 상태에서 실행 상태로(`디스패치`) 이동한다. 이때 프로세스에게 주어지는 작업 시간을 타임 슬라이스 또는 타임 퀸텀이라고 한다. 타임아웃은 인터럽트의 일종인데 정확히 말하면 '클록으로부터의 인터럽트'이다. 

시분할시스템은 위에 4가지 상태로도 작동되지만 **대기**상태를 넣어 효율을 높일 수 있다. 대기 상태란 실행 상태에서 입출력을 요구할때 변하





프로세스의 구조는 코드영역, 데이터영역(일반 데이터영역+힙영역), 스택영역로 이루어진다. 워드를 예로 들면 프로그램은 코드영역에, 편집 중인 문서는 데이터 영역에, 운영체제가 워드를 작동하기 위해 사용하는 부가정보는 스택 영역에서 관리한다.  

||코드영역|데이터영역|스택영역|
|:---:|:---:|:---:|:---:|
|담는것|프로그램의 텍스트|변수나 파일 등|운영체제가 사용하는 부가정보|
|기능|읽기 전용|읽기/쓰기|숨김 영역|
|비고|텍스트 영역으로도 불림|일반 데이터영역,힙영역으로 나뉨||

fork() 시스템 호출은 실행 중인 프로세스를 복사하여 새로운 프로세스를 만드는 함수이다. 기존 프로세스와 복사된 프로세스는 다른 부분이 있는데 PID(자신), PPID(부모), CPID(자식)이다. fork의 장점은 다음과 같다. 
* 생성 속도가 빠르다
* 자원을 상속할때 추가 작업이 없다
* 시스템 관리를 효율적으로 할 수 있다 : 프로세스 종료시 자원 정리를 부모에게 맡김

exac() 시스템 호출은 기존 프로세스를 새로운 프로세스로 전환하는 함수이다. exac()의 목적은 프로세스의 구조를 재활용하는 것이다. 보통 fork()와 exac()을 같이 사용하는데 fork()로 구조를 만들고 exac()으로 내용만 바꾸는 것이다. exac()을 동작 과정은 코드영역, 데이터영역이 바뀌고, 스택영역이 리셋된다. 단, PID, PPID, CPID, 메모리 관련사항은 바뀌지 않지만, 그외 pc레지스터 등과 같은 레지스터들은 모두 리셋된다. 

# CPU 스케줄링

`CPU 스케줄링 알고리즘 과제(저수준 스케줄링)`

# 프로세스 동기화
---
layout: post
title: "독서: 윤성우 열혈 c++ 프로그래밍"
---
이 책은 c와 c++의 차이점을 이야기 하는것부터 시작되며, c++가 어떻게 객체지향을 이루고 있는지를 객체지향의 도입, 전개, 완성의 목차로 다루고 있다. 나는 대학교에서 이미 c언어와 c++언어를 어느정도 배웠기 때문에 가볍게 읽을 수 있었고, 중간중간 새로 알게된 흥미로운 내용도 있었다.

# C++로의 전환

c++는 기본적으로 c의 내용을 포함하고 있다. c와 c++의 차이는 다음과 같다. 

||c|c++|
|:---:|:---:|:---:|
|입출력|printf / scanf|cout / cin|
|함수 오버로딩|X|O|
|매개변수 디폴트 값|X|O|
|인라인 함수|X|O|
|이름공간|X|O|
|bool 자료형|X|O|
|참조자 &|X|O|
|동적 메모리 할당|malloc / free|new / delete|
|라이브러리 형식|ex) stdio.h|ex) cstdio|

# 객체지향의 도입

`객체지향 프로그래밍`이란 어떠한 문제에대해서 그속에 물체 또는 추상적 개념을 프로그램 상의 객체로 옮겨와 문제를 해결하는 프로그래밍이다. 이러한 객체는 `클래스`를 통해 만들 수 있다. 클래스란 틀이다. 하나의 클래스는 여러개의 객체를 찍어낼 수 있다. 클래스로 만들어진 데이터를 객체라하고, 그 안에는 멤버변수, 멤버함수가 있다.

c++의 클래스와 비교되는 것은 구조체이다. 구조체란 관련있는 데이터와 함수들의 묶음으로, 클래스는 여기에 더해 `접근제어 지시자`(public, private, protected)가 포함되어 있다. 접근제어 지시자를 통해 `정보은닉`을 할 수 있다. 정보은닉이란 외부에서 객체 안에 변수에 접근할 수 없게 만드는 것이다. 정보은닉의 목적은 프로그래머의 실수를 방지하는 것이다. 또한 정보은닉을 통해 `캡슐화`를 할 수 있다. 캡슐화란 쉽게말해 불필요하게 나누어진 객체의 데이터 처리 과정들을 하나로 묶는것을 말한다. 사용자는 캡슐화된 함수 하나만 실행시키면 되기 때문에 사용하기도 쉽고, 오류를 잡기도 쉽다. 

객체는 탄생과 죽음이 있고, 이는 클래스의 `생성자`와 `소멸자`로 표현된다. 생성자는 이름이 클래스의 이름이고 반환형이 없는 함수이다. 생성자는 멤버변수를 초기화하는 역할을 한다. 이때 `멤버 이니셜라이저`를 사용하면 대입 연사자를 사용하는 것보다 효율적이며, 이것은 **const와 참조자 멤버변수도 초기화**할 수 있다. 만약 매개변수가 같은 클래스의 객체이면 복사생성자가 호출되는데, 말그대로 객체의 모든 멤버변수가 복사된다. 이를 `얕은 복사`라 한다. 문제는 포인터 멤버변수가 복사되면 두 객체의 포인터 멤버변수가 하나의 데이터를 가리킨다는 것이다. 한쪽에서 데이터를 수정하면 반대쪽에도 영향을 주고, 만약 한쪽에 의해 데이터가 삭제라도 되면 큰 문제가 발생한다. 따라서 포인터 멤버변수를 만나면 **새로운 데이터를 만들어 데이터 값을 복사해야한다**. 이를 `깊은 복사`라 한다. 복사생성자가 호출되는 시점은 3가지가 있다. 생성자로 직접 호출했을 때(대입연산자를 사용했을 때), 객체를 매개변수로 받아올 때, 함수의 반환형으로 객체가 반환될 때이다. 소멸자는 생성자에서 앞에 '~'가 붙은 형태이다. 소멸자는 메모리 누수를 막기위해 동적 할당된 메모리 공간을 소멸시켜야 한다.

클래스에서는 각종 키워드가 있다.

|키워드|설명|
|:---|:---|
|const|변수를 수정할 수 없게 한다. 이니셜라이즈를 통해 초기화 가능하다.|
|static|같은 클래스에서 한번만 초기화하게 한다.|
|friend|지정된 클래스에서 private 영역에 접근할 수 있게한다.|
|mutable|이 키워드가 붙은 변수는 const 함수에서 값 변경이 가능하다.|
|explicit|대입연산자가 복사생성자로 대체되는 것을 방지한다. | 

**주의할 점**
* 복사생성자의 매개변수는 참조형이 아니면 무한루프
* 객체를 생성할 때 ClassA a()로 작성하면 함수 선언과 동일한 형식이기 때문에 오류

# 객체지향의 전개

# 객체지향의 완성